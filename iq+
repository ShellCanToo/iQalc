#!/bin/sh
# IQ+/iq+ - Extended version of the iqalc/iq calculator

# Copyright Gilbert Ashley 6 August 2023
# Contact:perceptronic@proton.me  Subject-line: iQalc

# Main functions: pow, nroot, logx, exp, ipow, epow
# Other functions: fpow, getConst, iqXhelp

# disable some style checks and un-helpful suggestions
# shellcheck disable=SC2086,SC2004,SC2046,SC2034,SC2154,SC1091,SC1090,SC2123

iqplusversion=1.82

# getConst - simplify for more efficiency
# iq+ - increase standard constants to 32 places, with short versions of 12 places
# iq+ - add ln(2), log2(e), ln(10)  and log10(e) constants
# iq+ - double-quote nested bracket expansions
# epow - extensive rewrite
# logx - extensive rewrite
# nrt_solv - use tsst instead of cmp3w
# pow - extensive rewrite, add support for SigScale, refine results and restrictions
# ipow - removed

# default precision 
defprec=${defprec:-6}

# pow - raises a decimal number to a given power
# depends on: 'logx' 'exp' 'fpow' 'mul' 'div'
pow_help() {
echo "   'pow' usage: 'pow [-s?]  [-S?] base [^] exponent'
    
    Raises a number (base) to a power (exponent).
    When the exponent is an integer, base and exponent
    can be any size and precision is unlimited.
    Example: 'pow -s9 3.141592 ^ 6' = 961.387993507
    Example: 'pow -s12 12.141592 ^ -6' = 0.000000312137
    Supports Significant Digit scaling, with -S? option.
    Example: 'pow -S12 12.141592 ^ -6' = 0.000000312137674316
    
    Decimal exponents are supported, within a limited range.
    Output precision is limited to 12 decimal places.
    
    If base < 1, exponent can be any positive number:
    Example: 'pow -S6 0.53428 ^ 19.9345' = 0.00000374291
    
    If exponent < 1, base must be less than 100:
    Example: 'pow -s12 99.5342862 ^ 0.9345' = 73.638595054326
    
    If base and exponent are both greater than 1, base must
    be <10, and base+exponent must be less than 14:
    Example: 'pow -s6 5.3765 3.8184' = 615.658477
    Example: 'pow -s8 2.718282 ^ 9.141592' = 9335.620993414
    Example: 'pow -s9 2.718282 ^ -9.141592' = 0.000107116
    Example: 'pow -S9 2.718282 ^ -9.141592' = 0.000107116602
    " 
}
pow() { scale_pow=$defprec SigScale=0
    case $1 in -s*) scale_pow=${1#*-s} Stag=s ; shift ;; 
        -S*) scale_pow=${1#*-S}  SigScale=1 Stag=S ; shift ;; 
        ''|-h) pow_help >&2 ; return 1 ;;esac
    pbase=$1 ; shift ; case $1 in '^') shift ;;esac
    case $1 in '') pow_help >&2 ; return 1 ;;esac
    pexp=$1 pexpneg='' pbaseneg=''
    # separate and remove neg signs
    case $pbase in '-'*) pbaseneg='-' pbase=${pbase#*?} ;;esac
    case $pexp in '-'*) pexpneg='-' pexp=${pexp#?*} ;;esac
    # separate integer and fractional parts
    case $pbase in .?*) pbase_int=0 pbasefrac=${pbase#*.} ;; *?.?*) pbase_int=${pbase%.*} pbasefrac=${pbase#*.} ;;
        *) pbase_int=$pbase pbasefrac=0 ;;esac
    case $pexp in .?*) pexp_int=0 pexpfrac=${pexp#*.} ;; *?.?*) pexp_int=${pexp%.*} pexpfrac=${pexp#*.} ;;
        *) pexp_int=$pexp pexpfrac=0 ;;esac
    # remove extra leading zeros from integers
    while : ;do case $pbase_int in '0'?*) pbase_int=${pbase_int#?*} ;; *) break ;;esac ;done
    while : ;do case $pexp_int in '0'?*) pexp_int=${pexp_int#?*} ;; *) break ;;esac ;done
    # remove extra trailing zeros from fractions
    while : ;do case $pbasefrac in *?'0') pbasefrac=${pbasefrac%?*} ;; *) break ;;esac ;done
    while : ;do case $pexpfrac in *?'0') pexpfrac=${pexpfrac%?*} ;; *) break ;;esac ;done
    # recombine
    pbase=$pbase_int'.'$pbasefrac  pexp=$pexp_int'.'$pexpfrac
    # special cases and easy answers
    case "$pbaseneg""$pbase" in
        0.0) case "$pexpneg""$pexp" in -*) echo "inf" >&2 ; return ;;
                0.0) echo 1.0 ; return ;; *) echo 0.0 ; return ;;esac ;;
        1.0) echo 1.0 ; return ;;
        #-*) [ "$pexpfrac" != 0 ] && { echo "-->pow: NaN" >&2 ; return 1 ;}
        # Wolfram doesn't observe this, like Keisan/Casio did ??
        #    [ $((pexp_int%2)) -eq 0 ] && pbaseneg='' ;;
    esac
    # more special cases
    case "$pexpneg""$pexp" in
        0.0) echo 0.0 ; return ;; 1.0) echo $pbaseneg$pbase ; return ;;
        -1.0) [ 1 = $SigScale ] && scale_pow=$(( $scale_pow + ${#pbase_int} - 1 ))
                div -s$scale_pow  1 / $pbaseneg$pbase ; return ;;
    esac
    # if the exponent is an integer, delegate to mul, fpow or epow
    case $pexpfrac in 
        0)  # if exponent is integer, use ipow/epow
            case $pexp_int in 
                1) pres=$pbase ;; # cant get here
                2) pres=$( mul -s$scale_pow $pbase $pbase ) ;;
                *)  case $pbasefrac in 
                        # both base and exp are integers, so use fpow for 4X faster result
                        0) pres=$( fpow -s$scale_pow $pbase $pexp_int ) ;;
                        # for decimal base and integer exponent, epow does the job alone
                        *) epow -${Stag}$scale_pow $pbaseneg$pbase $pexpneg$pexp_int ; return ;;
                    esac ;;
            esac
        ;; 
        *)  # if exponent is non-integer, calculate decimal-only powers
            # using: a^x = e^(x(ln(a)) for exponents with integer and
            # decimal: a^x_int.x_frac = ( e^x_int ) * ( e^(x_frac(ln(a)) )
            
            # limit output scale to 12 places, set default intermediate scale
            [ $scale_pow -gt 12 ] && scale_pow=12
            pmed_scale=$((scale_pow+3))
            
            # apply all the limitations
            case $pbase_int in 
                0)  # base <1
                    case $pexp_int in 
                        0)  # exponent <1 -- if base <0.184, take the inverse and reinvert later
                            if tsst $pbase -lt 0.184 ; then
                                case $pexpneg in -) pmed_scale=$(( $pmed_scale + 4 )) ;;
                                    *)  pbase=$( div -s$pmed_scale 1 / $pbase ) ; pexpneg='-' ;;
                                esac
                            fi
                        ;; 
                        *)  # exponent >1
                            [ '-' = "$pexpneg" ] && { echo "-->pow: For base<1.0, negative exponent not supported" >&2 ; return 1 ;}
                            # if base is tiny and exponent>9, bail out
                            if tsst $pbase -lt 0.184 ; then
                                [ $pexp_int -gt 9 ] && { echo "-->pow: For base<0.184, exponent must be <10" >&2 ; return 1 ;}
                            fi
                            # do integer part of exponent separately
                            first=''
                            if [ ${pexp_int} -eq 1 ] ; then
                                first=$pbase
                            else
                                # answer may be small, use epow to ensure significant digits
                                first=$( epow -${Stag}$pmed_scale $pbase $pexp_int )
                            fi
                            # raise scale for SigScale
                            if [ 1 = "$SigScale" ] ; then
                                frac=${first#*.}  zees=${frac%%[!0]*} 
                                pmed_scale=$(( $pmed_scale + ${#zees} ))
                                scale_pow=$(( $scale_pow + ${#zees} ))
                            fi
                            # remove integer part from exponent
                            pexp='0.'$pexpfrac
                        ;;
                    esac
                ;;
                *)  # base >1
                    # a crude, but effective upper range limit
                    range=$(( $pbase_int + $pexp_int ))
                    case $pexp_int in 
                        0)  # exponent <1
                            [ $range -gt 99 ] && { echo "-->pow: 'base' must be less than 99 " >&2 ; return 1 ;} ;;
                        *)  # exponent >1
                            [ $range -gt 13 ] && { echo "-->pow: base+exponent must be <14 " >&2 ; return 1 ;}
                            [ ${pbase_int} -gt 9 ] && { echo "-->pow: base must be <10 " >&2 ; return 1 ;}
                            [ -z "$pexpneg" ] && pmed_scale=$(( $pmed_scale + 3 ))
                            if [ ${pexp_int} -eq 1 ] ; then
                                first=$pbase
                            else
                                first=$( fpow -s$(($pmed_scale)) $pbase $pexp_int )
                            fi
                            pexp='0.'$pexpfrac
                            ;;
                    esac
                ;;
            esac
            # reduce the exponent close to zero where accuracy is best
            case $pexp in
                0.[012]*) reduced=0 ;;
                0.[3456]*) reduced=3 
                    pexp=$( div -s$pmed_scale $pexp / 3 ) ;;
                *)  reduced=4
                    pexp=$( div -s$pmed_scale $pexp / 4 ) ;;
            esac
            
            lscale=$pmed_scale
            zscale=$pmed_scale
            # take the log of the base
            plog=$( logx -s$lscale n $pbase )
            # multiply by the exponent
            pprod=$( mul -s$pmed_scale $pexp $plog )
            
            #[ $zscale -gt 16 ] && zscale=16
            pres=$( exp_z -s$zscale $pprod )
            
            #echo pexp=$pexp reduced=$reduced >&2
            #echo range=$range scale_pow=$scale_pow pmed_scale=$pmed_scale lscale=$lscale zscale=$zscale >&2
            #echo plog=$plog pprod=$pprod >&2
            
            # restore any reduced decimal part
            if [ 0 != $reduced ] ; then
                pres=$( fpow -s$pmed_scale $pres $reduced )
            fi
            # multiply any integer part by decimal result
            if [ -n "$first" ] ; then
                pres=$( mul -s$pmed_scale $first $pres)
            fi
        ;;
    esac
    # if the exponent is negative, invert the result
    case $pexpneg in '-') 
        if [ 1 = "$SigScale" ] ; then 
            pres_int=${pres%.*}
            scale_pow=$(( $scale_pow + ${#pres_int} - 1 ))
        fi
            pres=$( div -s$scale_pow 1 / $pres ) 
        ;;
    esac
    # truncate or trim to scale
    case $scale_pow in 0) echo $pbaseneg${pres%.*} ;; 
        *) pfrac=${pres#*.} ; while [ ${#pfrac} -gt $scale_pow ] ;do pfrac=${pfrac%?*} ;done
        echo $pbaseneg${pres%.*}'.'${pfrac:-0} ;; 
    esac

} ## pow
# scale_pow= pbase= pexp= pbaseneg= pexpneg= pbase_int= pbasefrac= pmed_scale=
# plog= pprod= pres= pfrac= rangecheck=

# epow - pow function with answers in normal scale, SigFig scale or e-notation
# depends on: 'logx' 'mul'
# used by: 'pow' 
epow_help()  {
echo "    'epow' usage: 'epow [-s?,-S?,-e?] base [^] exponent' 
    
    Both 'base' and 'exponent' must be positive numbers.
    'base' can be an integer or decimal, 'exponent' must be integer.
    'epow' returns powers with answers in three forms: normally
    scaled outputs, significant digits or exponential notation.
    Output format is controlled with 3 scaling options: -s? -S? or -e?
    
    Example usage for normal scaling: 'epow -s9 0.14 7' = 0.000001054
    Example for significant digits: 'epow -S9 0.14 7' = 0.00000105413504
    Example for exponential notation: 'epow -e9 0.14 7' = 1.05413504e-6
    Example for exponential notation: 'epow -e12 42.818 7' = 2.638667359224e11
    With exponential notation, accurate to ~X^2,000,000
    Example: epow -e6 0.0105 ^ 1000000 = 1.990993e-1978811
    "
}
epow() { fstprec=$defprec  SigScale=0 E_note=0 bneg='' expneg=''
    case $1 in -s*) fstprec=${1#*-s} ; shift ;; -S*) fstprec=${1#*-S}  SigScale=1 ; shift ;;
            # e-notation scaling       
        -e*) fstprec=${1#*-e} E_note=1 ; [ $fstprec -lt 2 ] && fstprec=2 ; shift ;; ''|-h) epow_help >&2 ; return 1 ;;
    esac
    
    base=$1 ; shift
    case $base in '-'*) bneg='-' base=${base#*-} ;;esac
    case $base in *.*) baseint=${base%.*} basefrac=${base#*.} 
        while : ; do case $basefrac in *?0) basefrac=${basefrac%?*} ;; *) break ;;esac ; done
        while : ; do case $baseint in 0*) baseint=${baseint#*?} ;; *) break ;;esac ; done
        base=$baseint'.'$basefrac
        ;;
    esac
    
    # skip any carat
    case $1 in '^') shift ;;esac
    
    case $1 in '') epow_help >&2 ; return 1 ;;
        *.*[!0]*) echo "-->epow: fractional exponents not supported: $1" >&2 ; return 1 ;;
        *) exp=${1%.*} ; shift ;;
    esac
    case $exp in '-'*) expneg='-' exp=${exp#*-} ;;esac
    
    # quick detection of powers of ten
    case $base in
        *[!10.]*|*1*1*) : ;;
        1*) int=${base%.*}  rest=${int#*?}  
            case $E_note in 
                1) echo $bneg'1.0e'$(( ${#rest} * $exp )) ;;
                *)  cnt=1  zees=$rest
                    while [ $cnt -lt $exp ] ; do zees=$zees${rest} ; cnt=$((cnt+1)) ;done
                    [ $fstprec = 0 ] && echo '1'$zees || echo $bneg'1'$zees'.0' ;;
            esac
            return ;;
        *.*1) frac=${base#*.} rest=${frac%?*}
            case $E_note in 
                1) echo $bneg'1.0e-'$(( ${#rest} * $exp )) ;;
                *)  cnt=0  zees=$rest
                    while [ $cnt -lt $exp ] ; do zees=$zees${rest} ; cnt=$((cnt+1)) ;done
                    echo $bneg'0.'$zees'1'
                    ;;
            esac
            return 
        ;;
    esac
    
    logscale=$(( ${#exp} + 1 ))

    case $base in 
        '.'|'') echo 0.0 ; return ;;
        .?*) base=${base#*.} zeros=0 zees=''
            # remove and count any leading zeros
            zees=${base%%[!0]*}  base=${base#*"${zees%%}"}
            zeros=${#zees}
            # take the log10 of remaining significant digits
            bplog=$( logx -s$logscale 10 '.'$base )
            # construct absolute log by adding zero size 
            fulllog=$zeros'.'${bplog#*.}
            # log10(base) * exponent = number of leading zeros in result
            ofsz=$( mul -s0 $fulllog $exp )
            #echo A bplog=$bplog zeros=$zeros fulllog=$fulllog >&2
            # normal or exponential scaling
            fst_scale=$((fstprec + 3))
            # inversion creates integer digits so adjust scale to include those
            case $expneg in 
                '-') [ 0 = $E_note ] && fst_scale=$((fstprec + $ofsz + 3)) ;;
            esac
            # log of fractions is negative
            E='-'$ofsz
            base='.'$base
        ;;
        *?.?*)  
            int=${base%.*} frac=${base#*.}
            rest=${int#*?} first=${int%%"${rest}"}
            bplog=$( logx -s$logscale 10 ${first}'.'${rest}${frac} )
            fulllog=$(( ${#int} - 1 ))'.'${bplog#*.}
            # integer size of result
            E=$(( $( mul -s0 $fulllog $exp ) + 1 ))
            case $expneg in 
                '-') fst_scale=$((fstprec + 3)) ;;
                *) [ 1 = $E_note ] && fst_scale=$((fstprec + 3)) || fst_scale=$((fstprec + $E + 3)) ;;
            esac
            base='.'${int}${frac}
        ;;
        *)  int=${base%.*}  rest=${int#*?}  first=${int%%"${rest}"}
            bplog=$( logx -s$logscale 10 ${first}'.'${rest} )
            fulllog=$(( ${#int} - 1 ))'.'${bplog#*.}
            # integer size of result
            E=$(( $( mul -s0 $fulllog $exp ) + 1 ))
            case $expneg in 
                '-') fst_scale=$((fstprec + 3)) ;;
                *) [ 1 = $E_note ] && fst_scale=$((fstprec + 3)) || fst_scale=$(($E + 3)) ;;
            esac
            base='.'$int ;;
    esac
    
    # do the operation -everything has been made into a fraction
    # keep only the significant digits after each multiplication
    out_pm=$base
    exp=$((exp - 1))
    while : ; do 
        case $exp in *[13579])
            out_pm=$( mul -s$fst_scale $out_pm $base ) 
            case $out_pm in 0.0*) out_pm='.'${out_pm#*???} ;; esac
        esac
        exp=$((exp/2))
        [ $exp -eq 0 ] && break
        base=$( mul -s$fst_scale $base $base )
        case $base in 0.0*) base='.'${base#*???} ;; esac
    done
    
    case $expneg in 
        '-')  
            case $E in 
                '-'*)  
                    if [ 1 = "$E_note" ] ; then
                        out_pm=$( div -s$fstprec 1 / $out_pm )
                        echo ${bneg}$out_pm'e'${E#*-}
                        return
                    fi
                    E=$(( ${E#*-} + 1 ))
                    out_pm=$( div -s$(( $fstprec + $E )) .1 / $out_pm )
                ;;
                *)  if [ 1 = "$E_note" ] ; then
                        out_pm=$( div -s$fstprec 1 / $out_pm )'e-'$E
                        echo ${bneg}$out_pm
                        return
                    fi
                    E='-'$(( $E - 1 ))
                    out_pm=$( div -s$fstprec .1 / $out_pm )
                ;;
            esac
        ;;
        *)  if [ 1 = "$E_note" ] ; then
                E=$((E-1)) ; out_pm=${out_pm#*.}  mask=${out_pm#*?}
                while [ ${#mask} -gt $fstprec ] ; do mask=${mask%?*} ; done
                echo ${bneg}${out_pm%"${mask}"*}'.'$mask'e'$E
                return
            fi
        ;;
    esac
    
    case $E in 
        -*) [ $fstprec = 0 ] &&  { echo 0 ; return ;}
            ofs=${E#*-}  out_pm=${out_pm#*.}  pad=''
            while [ ${#pad} -lt $ofs ] ; do pad=$pad'0' ; done
            if [ 0 = $SigScale ] ; then
                # show leading zeros if requested scale is smaller
                [ $fstprec -le ${#pad} ] && { echo ${bneg}0.$pad ; return ;} || fstprec=$(( $fstprec - $ofs ))
            fi
            out=''
            # accumulate needed significant digits
            while [ -n "$out_pm" ] ; do
                mask=${out_pm#*?}
                out=${out}${out_pm%"${mask}"*}
                [ ${#out} -eq $fstprec ] && break
                out_pm=$mask 
            done
            echo ${bneg}0.${pad}$out
        ;;
        *)  ofs=$E  out_pm=${out_pm#*.} out=''
            while [ $ofs -gt 0 ] ; do
                mask=${out_pm#*?}
                dig=${out_pm%"${mask}"*}
                # default '0' for trailing zeros
                out=${out}${dig:-0}
                ofs=$((ofs-1)) out_pm=$mask
            done
            # exit for integer output
            case $fstprec in 0) echo ${bneg}${out%.*} ; return ;; esac
            # process decimal part, if any
            out=$out'.' cnt=0
            while [ $cnt -lt $fstprec ] ; do 
                mask=${out_pm#*?}
                out=${out}${out_pm%"${mask}"*}
                out_pm=$mask
                [ -z "$out_pm" ] && break
                cnt=$((cnt+1)) 
            done
            case $out in *.) echo ${bneg}$out'0' ;;
                *) echo ${bneg}$out ;;
            esac
        ;;
    esac
} ## epow
# fstprec= SigScale= E_note= base= exp= fst_scale= zeros= dummy= bplog= E= base_int= base_int_size= out_pm=
# msk1= cnt_p= scratch= out_frac=

# nroot - find the 'n-th' root of a number
# depends on: 'nrt_solv' 'div'
nroot_help() {
echo "   'nroot' usage: 'nroot [-s?] Number Nth'
    
    'Number' must be a positive integer or decimal
    'Nth' must be a positive integer
    Example: 'nroot -s6 4.3 10' for: 10th root of 4.3
    Example: 'nroot -s8 43.225 2' for: sqrt of 43.225
    Example: 'nroot -s12 2 2' = 1.414213562373
    "
}
nroot() { scale_nrt=$defprec
    case $1 in -s*) scale_nrt=${1#*-s} ; shift ;; ''|-h) nroot_help >&2 ; return 1  ;;esac
    case $2 in '') nroot_help >&2 ; return 1  ;; 
        *.*) echo "-->nroot: Nth must be an integer" >&2 ; return 1 ;; 
    esac
    base_nrt=$1 N_th=$2 # get the inputs
    case $N_th in '-'*) Nth_neg='-' N_th=${N_th#*-} ;; esac # separate neg from nth
    while : ; do case $N_th in 0?*) N_th=${N_th#*?} ;; *) break ;; esac ; done # depad nth
    case $base_nrt in '-'*) nrt_neg='-' base_nrt=${base_nrt#*-} ;; esac # separate neg from base
    case $base_nrt in 0.*|.*) nrt_int=0 nrt_frac=${base_nrt#*.} ;; # separate base int and frac
        *.*) nrt_int=${base_nrt%.*} nrt_frac=${base_nrt#*.} ;; *) nrt_int=$base_nrt nrt_frac=0 ;;
    esac
    while : ; do case $nrt_int in 0?*) nrt_int=${nrt_int#*?} ;; *) break ;; esac ; done # depad base int
    while : ; do case $nrt_frac in *?0) nrt_frac=${nrt_frac%?*} ;; *) break ;; esac ; done # depad base frac
    base_nrt=$nrt_int'.'$nrt_frac
    # handle special cases
    case $nrt_neg$base_nrt in
        0.0) case "$Nth_neg""$N_th" in -*) echo "-->nroot: NaN" >&2 ; return 1 ;;  
                0) echo 1.0 ; return ;; *) echo 0.0 ; return ;;esac ;;
        1.0) echo 1.0 ; return ;;
        -*) [ $((N_th%2)) -eq 0 ] && { echo "-->nroot: NaN" >&2 ; return 1 ;} ;;
    esac
    case $Nth_neg$N_th in
        0) echo 0.0 ; return ;; 1) echo $nrt_neg$base_nrt ; return ;;
        -1) div -s$scale_nrt  1 / $nrt_neg$base_nrt ; return ;;
    esac
    # If we get here, do scale-compensation for small bases, or user requests scale=0
    if [ $scale_nrt -eq 0 ] ; then
        scale_nthrt=2
    else
        # a complete solution for bases <0.0?* would mean counting leading zeros, but let's try this
        case $base_nrt in 0.0*) scale_nthrt=$(( (scale_nrt*12) / 10 )) ;; *) scale_nthrt=$scale_nrt ;; esac
    fi
    # for Nth which are multiples of 10, break into chunks
    if [ $((N_th % 10)) -eq 0 ] ; then
        while [ $N_th -gt 9 ] ;do
            N_th=$((N_th / 10))
            base_nrt=$(nrt_solv -s$scale_nthrt $base_nrt 10 )
        done
        [ $N_th -gt 1 ] && base_nrt=$(nrt_solv -s$scale_nthrt $base_nrt $N_th )
    else
        # otherwise use the longer method
        if [ $N_th -gt 9 ] ; then
            solved=0 # try using factors
            for try in 9 8 7 6 5 4 3 2 ;do
                if [ $((N_th % try)) -eq 0 ] ; then
                    N_th=$((N_th / try))
                    base_nrt=$(nrt_solv -s$scale_nthrt $base_nrt $try )
                    base_nrt=$(nrt_solv -s$scale_nthrt $base_nrt $N_th )
                    solved=1 ; break
                fi
            done
            # number is prime or its' smallest factor is >9
            [ 0 = "$solved" ] && base_nrt=$( nrt_solv -s$scale_nthrt $base_nrt $N_th )
        else
            # for small N_th
            base_nrt=$( nrt_solv -s$scale_nthrt $base_nrt $N_th )
        fi
    fi
    case $Nth_neg in '-') base_nrt=$( div -s$scale_nthrt 1 / $base_nrt ) ;; esac
    # messy(still) decomposition of intermediate scales and output
    case $scale_nthrt in "$scale_nrt") echo $nrt_neg$base_nrt ;; 
        *)  case $scale_nrt in 0) echo $nrt_neg${base_nrt%.*} ;;
                *)  nrt_frac=${base_nrt#*.} nrt_out_frac=
                    while [ ${#nrt_out_frac} -lt $scale_nrt ] ; do   
                        nrt_msk=${nrt_frac#*?} nrt_out_frac=$nrt_out_frac${nrt_frac%"$nrt_msk"*} nrt_frac=$nrt_msk
                    done
                    echo $nrt_neg${base_nrt%.*}'.'$nrt_out_frac ;;
            esac ;;
    esac
    
} ## nroot -s7 4.2 5 (for 5th root of 4.2)
# scale_nthrt= N_th= base_nrt= solved=

# logx - returns logarithms in base 10, e/n or 2
# depends on: 'getConst' 'tsst' 'mul' 'div' 'add'
# This uses a fast approximation with very good precision
# uses the inverse hyperbolic tangent method
# ln(x) = 2{ (x-1/x+1) + 1/3(x-1/x+1)^3 + 1/5(x-1/x+1)^5 + ...}
logx_help() {
echo "    'logx' usage: 'logx [-s?] base number'
    
    Calculates logarithms in base n/e, 2, 3, 4, or 10
    Example log base10: 'logx -s8 10 6.7' for: log(6.7)
    Example log base natural: 'logx -s7 n 6.7' for: ln(6.7)
    Example log base2: 'logx -s7 2 6.7' for: log2(6.7)
    
    Accurate up to 30 Decimal places.
   "
}
# logn - complete rewrite of logx
logx() { scale_lx=$defprec
    case $1 in -s*) scale_lx=${1#*-s} ; shift ;; ''|-h) logx_help >&2 ; return 1 ;;esac
    case $2 in '') logx_help >&2 ; return 1 ;;esac
    base=$1 x=$2
    # special cases and errors
    case $x in # input errors and logx(1) are universal for all bases
        -*) echo "-->logx: NaN" >&2 ; return 1 ;;
        0|0.0|.0) echo "-->logx: NaN" >&2 ; return 1 ;; 
        1|1.0) echo 0.0 ; return ;;
        .*) x='0'${x} ;;
    esac
    # make sure the requested base is supported
    case $base in [ne234]|10) : ;;
        *) echo "-->lognew: False base input ($base) : e, n, 2, 3, 4, or 10 allowed" >&2 ; return 1 ;;
    esac
    
    # increase internal scaling
    e_scale=$(($scale_lx+3))
    
    # handle easy base 10 inputs
    if [ $base = 10 ] ; then
        case $x in *[!01.]*|*1*1*) : ;;
            0.*) frac=${x#*.} frac=${frac%"${frac##*[!0]}"*}
                [ -z "$frac" ] && { echo "-->logx: NaN" >&2 ; return 1 ;}
                echo '-'${#frac}'.0' ; return ;;
            1*.?*) frac=${x#*.} int=${x%.*}
                echo $((${#int}-1))'.0' ; return ;;
            1*) echo $((${#x}-1))'.0' ; return ;;
        esac
        # get the conversion factor for base 10
        case $scale_lx in ?) conv=$l10e ;;
            *) conv=$( getConst L10E $e_scale ) ;;
        esac
    fi
    
    # this algorithm converges poorly near e(2.7182...),
    # or any of its' negative powers (0.36787...0.13533...)
    # first bring x into the range of [10^1,10^-1] or 10 > X > 0.1
    drank=0 x_int=${x%.*}
    # reduction in base 10
    if [ ${#x_int} -gt 1 ] ; then
        pad='1' dreduc=1 drank=1
        while [ ${#pad} -lt ${#x_int} ] ;do pad='0'$pad drank=$(($drank+1)) ;done
        x=$( mul $x '0.'$pad )
        case $scale_lx in ?) Ln10=$ln10 ;;
            *) Ln10=$( getConst LN10 $e_scale ) ;;esac
        case $drank in
            1) dreduc=$Ln10 ;;
            *) dreduc=$( mul -s$e_scale $drank $Ln10 ) ;;esac
    else
        # for small x, with leading zeros increase x by powers of ten
        case $x in 0.[0]*) pad='' dreduc=1 drank=0
            frac=${x#*.} zees=${frac%%[!0]*}
            while [ ${#pad} -lt ${#zees} ] ;do pad=$pad'0' drank=$(($drank+1)) ;done
            x=$( mul $x '1'$pad )
            case $scale_lx in ?) Ln10=$ln10 ;;
                *) Ln10=$( getConst LN10 $e_scale ) ;;esac
            # negate ln10 to keep signs straight
            case $drank in
                1) dreduc='-'$Ln10 ;;
                *) dreduc=$( mul -s$e_scale $drank '-'$Ln10 ) ;;esac
            ;;
        esac
    fi
    # now reduce X to .4>x<1.0
    # further reduction/augmentation in base 2
    brank=0 breduc=0
    case $x in 0.[123]*) fctr='' 
            case $scale_lx in ?) breduc='-'$ln2 ;;
                *) breduc='-'$( getConst LN2 $e_scale ) ;;esac
                x=$( mul -s$e_scale $x 2 ) 
            ;; 
        0.[456789]*) fctr='' ;;
        [123].*) fctr=4 brank=2 ;;
        [456].*) fctr=8 brank=3 ;;
        [789].*) fctr=16 brank=4 ;;
    esac
    case $fctr in '') : ;;
        *)  case $scale_lx in ?) Ln2=$ln2 ;;
                *) Ln2=$( getConst LN2 $e_scale ) ;;esac
            breduc=$( mul $brank $Ln2 )
            x=$( div -s$e_scale $x / $fctr ) 
        ;;
    esac
    # set the number of iterations 
    its=$(( (scale_lx / 2) + 5))
    #[ $scale_lx -gt 25 ] && its=$((its+3))
    
    # y = 2 * ( (x-1/x+1) + ((x-1/x+1)^3)/3 + ((x-1/x+1)^5)/5 + (x-1/x+1)^7/7 ... )
    # get the initial ratio of (x-1/x+1)  
    ratio=$( div -s$e_scale $(add $x - 1) / $(add $x + 1) )
    #echo its=$its ratio=$ratio e_scale=$e_scale x=$x >&2
    # initialize acu and total to equal ratio
    total=$ratio acu=$ratio
    # square the ratio to jump two powers for each iteration
    r2=$( mul -s$e_scale $ratio $ratio )
    # do the iterations  (x-1/x+1)^3/3 ... (x-1/x+1)^5/5 ... (x-1/x+1)^7/7
    lxcnt=0 dvsr_series=3
    while [ $lxcnt -lt $its ] ;do
        acu=$( mul -s$e_scale $acu $r2 )
        case ${acu#*-} in *[!0.]*) : ;; *) break ;; esac
        total=$( add $total $(div -s$e_scale $acu / $dvsr_series) )
        lxcnt=$((lxcnt+1)) dvsr_series=$((dvsr_series+2))
    done
    #  y = 2 * ...
    lxout=$( mul -s$e_scale $total 2 )
    # print or convert the output according to the base conversion
    # factors derived by this formula: factor = 1 / ln(new-base)
    case $base in 
            [ne]) add -s$scale_lx $dreduc $breduc $lxout ; return ;;
            2)  case $scale_lx in ?) conv=$l2e ;;
                    *) conv=$( getConst L2E $e_scale ) ;; esac;;
            3)  case $scale_lx in ?) conv=0.910239226626 ;;
                    *) conv=0.91023922662683739361424016573610 ;; esac;;
            4)  case $scale_lx in ?) conv=0.721347520444 ;;
                    *) conv=0.72134752044448170367996234050094 ;; esac;;
    esac
    
    lxout=$( add $dreduc $breduc $lxout )
    mul -s$scale_lx $lxout $conv
    
} ## lognew complete rewrite
# scale_lx= base= base_int= int= x= mask= frac= e_scale= drank= dreduc= brank= breduc=
# ratio= r2= total= lxcnt= dvsr_series= acu= dvsr_series= lxcnt= lxout= conv= fctr= Ln10= Ln2=


# exp - e^x - Eulers' number 'e' raised to 'x'
# depends on: 'exp_z' 'tsst' 'add' 'mul
# depends on: 'exp_z' 'tsst' 'add' 'mul
# precision is tuned to provide ~12 places for a wide range of inputs,
# where X<19 -tested down to ~X>0.00000002
exp_help() {
echo "    'exp' usage: 'exp [-s?] exponent'
    
    'e^x' - raises Euler's number 'e' to a given power 'x' (e^x),
    Example: 'exp -s15 3.6' returns: '36.598234443677978'
    Example: 'exp -s8 1.134' returns: '3.10806392'
    
    Accurate to ~12 places where X<19.0
    "
}
exp() { escale=$defprec
    case $1 in -s*) escale=${1#*-s} ; shift ;; ''|-h) exp_help >&2 ; return 1 ;;esac
    case $1 in '') exp_help >&2 ; return 1 ;; *) expx=$1 ;;esac
    expneg=''
    case $expx in '-'*) expneg='-'  expx=${expx#*-} ;;esac
    case $expx in '.'*) expx='0'$expx ;;esac
    
    # special cases for early exit
    case ${expneg}${expx} in
        0|.0|0.0) echo 1.0 ; return ;;
        1|1.0) getConst E $escale ; return ;;
        -1|-1.0) div -s$escale 1 / $( getConst E $escale ) ; return ;;
    esac
    
    e2scale=$((escale+2))
    
    # argument reduction
    # using limits of 1.1 gives us ~12 places of precision
    if tsst $expx -gt 0.7 ; then
        pad='1' ; cnt=0
        qr=$( div -s$e2scale $expx qr $( getConst LN10 $(($e2scale+2)) ) )
        mag=${qr% *} expx=${qr#*' '}  mag=${mag%.*}
        expout=$( exp_z -s$e2scale $expx )
        while [ ${#pad} -le $mag ] ; do pad=$pad'0' ; done
        case $expneg in '-') div -s$escale 1 / $( mul $expout $pad ) ;; 
            *) mul -s$escale $expout $pad ;; 
        esac
    else
        case $expneg in '-') div -s$escale 1 / $( exp_z -s$e2scale $expx )  ;; 
            *) exp_z -s$escale $expx ;;
        esac
    fi
} ## exp
# e^-x = 10-0.43429448190325x  log10(e)=0.434294481903251827651128917

### Back-end functions for pow nroot log
# fpow is used by: 'pow' 'nrt_solv'
# depends on: 'mul' 
fpow() { case $1 in -s*) fstprec=${1#*-s} ; shift ;; *) fstprec=$defprec ;;esac
    case $1 in -t*) truncprec=${1#*-t} ; shift ;; *) truncprec='' ;;esac
    base_fst=$1
    # these conditions shouldn't really happen here, but just in case:
    case $2 in 0) echo 1.0 ; return ;; 1) echo $base_fst ; return ;;
        2) mul -s$fstprec $base_fst $base_fst  ; return ;;
    esac
    
    out_fst=$1
    exp_fst=$(( $2 - 1 ))
    while : ; do
        [ $((exp_fst%2)) -ne 0 ] && out_fst=$( mul -s$fstprec $out_fst $base_fst )
        exp_fst=$((exp_fst/2))
        [ $exp_fst -eq 0 ] && break
        base_fst=$( mul -s$fstprec $base_fst $base_fst )
    done
    
    case $truncprec in '') echo $out_fst;;
        *) case $out_fst in *.*) fstfrac=${out_fst#*.} 
            while [ ${#fstfrac} -gt $truncprec ] ; do fstfrac=${fstfrac%?*} ; done
            echo ${out_fst%.*}'.'$fstfrac ;;
            *) echo $out_fst ;;esac ;;
    esac
} ## fpow
# fstprec= base_fst= exp_fst= out_fst=

# nrt_solv -backend root solver for 'nroot'
# depends on: 'fpow' 'tsst'
# Don't call this directly unless you know how to use it
nrt_solv() { case $1 in -s*) nthrtsprec=${1#*-s} ; shift ;; *) nthrtsprec=$defprec ;;esac
    goal=$1 goal_int=${1%.*} goal_nth=$2
    # get the integer part of the answer
    answ_int='' this_nth=5 
    if [ "${goal_int:-0}" = 0 ] ; then
        answ_int=0
    else
        case $goal_int in 1|2|3) answ_int=1 answ_size=1 ;;
                *) while : ;do    # get size of answers' integer and pad-up columns if needed
                        tsst "$( fpow -s0 '1'"$col" $goal_nth )" -gt $goal_int && { 
                            answ_size=${#col} col=${col%?*} ; break ;}
                        col=$col'0'
                    done ; answ_int='' ;;
        esac
        # search order for integer part: 5,9,7 - 5,1,3
        while : ;do
            this_product=$( fpow -s0 "$answ_int""$this_nth""$col" $goal_nth )
            signal=$( cmp3w $this_product $goal_int )
            [ $signal = "=" ] && { answ_int="$answ_int""$this_nth""$col" ; break ;}
            case $this_nth in
            '9') case $signal in '<') answ_int=$answ_int'9' this_nth=5 col=${col%?*} ;; '>') this_nth=7 ;;esac ;;
            '8') case $signal in '<') answ_int=$answ_int'8' this_nth=5 col=${col%?*} ;;
                                '>') answ_int=$answ_int'7' this_nth=5 col=${col%?*} ;;esac ;;
            '7') case $signal in '<') this_nth=8 ;; '>') this_nth=6 ;;esac ;;
            '6') case $signal in '<') answ_int=$answ_int'6' this_nth=5 col=${col%?*} ;; 
                                '>') answ_int=$answ_int'5' this_nth=5 col=${col%?*} ;;esac ;;
            '5') case $signal in '<') this_nth=9 ;; '>') this_nth=1 ;;esac ;;
            '4') case $signal in '<') answ_int=$answ_int'4' this_nth=5 col=${col%?*} ;;
                                '>') answ_int=$answ_int'3' this_nth=5 col=${col%?*} ;;esac ;;
            '3') case $signal in '>') this_nth=2 ;; '<') this_nth=4  ;;esac ;;
            '2') case $signal in '>') answ_int=$answ_int'1' this_nth=5 col=${col%?*} ;; 
                                '<') answ_int=$answ_int'2' this_nth=5 col=${col%?*} ;;esac ;;
            '1') case $signal in '>') answ_int=$answ_int'0' this_nth=5 col=${col%?*} ;; '<') this_nth=3 ;;esac ;;
            esac
            [ ${#answ_int} -eq $answ_size ] && break
        done
        # early exit if we already have the answer
        if tsst $this_product -eq $goal ; then
            case $nthrtsprec in 0) echo ${answ_int%.*} ;; *)  echo "${answ_int%.*}"".0" ;;esac
            return
        fi
    fi
    # do the fractional part
    answ_frac=''  answ_int=$answ_int'.' 
    # set a conservative scale for fpow to assure valid results
    fpow_scale=$(( (nthrtsprec * 13) / 10 ))
    this_nth=5 nthrtrunc=$((nthrtsprec+1))
    # Search order for fractional parts is: 5,9,7  5,3,1(was 5,1,3)
    while : ;do
        this_product=$( fpow -s$fpow_scale -t$nthrtrunc "$answ_int""$answ_frac""$this_nth" $goal_nth )
        signal=$( cmp3w $this_product $goal ) 
        [ $signal = "=" ] && { answ_frac="$answ_frac""$this_nth" ; break ;}
        case $this_nth in
            '1') case $signal in '<') this_nth=2 ;; '>') answ_frac=$answ_frac'0' this_nth=5 ;;esac ;;
            '2') case $signal in '<') answ_frac=$answ_frac'2' this_nth=5 ;; '>') answ_frac=$answ_frac'1' this_nth=5 ;;esac ;;
            '3') case $signal in '<') this_nth=4 ;; '>') this_nth=1 ;;esac ;;
            '4') case $signal in '<') answ_frac=$answ_frac'4' this_nth=5 ;; '>') answ_frac=$answ_frac'3' this_nth=5 ;;esac ;;
            '5') case $signal in '<') this_nth=9 ;; '>') this_nth=3 ;;esac ;;
            '6') case $signal in '<') answ_frac=$answ_frac'6' this_nth=5 ;; '>') answ_frac=$answ_frac'5' this_nth=5 ;;esac ;;
            '7') case $signal in '<') this_nth=8 ;; '>') this_nth=6 ;;esac ;;
            '8') case $signal in '<') answ_frac=$answ_frac'8' this_nth=5 ;; '>') answ_frac=$answ_frac'7' this_nth=5 ;;esac ;;
            '9') case $signal in '<') answ_frac=$answ_frac'9' this_nth=5 ;; '>') this_nth=7 ;;esac ;;
        esac
        [ ${#answ_frac} -eq $nthrtsprec ] && break 
    done
    # format output as needed
    case $nthrtsprec in 0) echo ${answ_int%.*} ;;
        *)  while [ ${#answ_frac} -gt $nthrtsprec ] ;do answ_frac=${answ_frac%?*} ;done
            echo ${answ_int%.*}'.'$answ_frac ;;
    esac
} ## nrt_solv
# nthrtsprec= goal_nth= goal= goal_int= answ_int= col= answ_size= this_nth= this_product= signal= answ_frac= nthrtrunc=

EE=2.71828182845904523536028747135266
ee=2.718281828459

LN10=2.30258509299404568401799145468436
ln10=2.302585092994
L10E=0.43429448190325182765112891891660
l10e=0.434294481903
LN2=0.69314718055994530941723212145817
ln2=0.693147180559
L2E=1.44269504088896340735992468100189
l2e=1.442695040888

PI=3.14159265358979323846264338327950
pi=3.141592653589 
PI_2=1.57079632679489661923132169163975
pi_2=1.570796326794
PI_4=0.78539816339744830961566084581987
pi_4=0.785398163397

PHI=1.61803398874989484820458683436563
phi=1.618033988749

# getConst - returns a truncated constant: 'pi', 'pi/2', 'pi/4' or
#  'phi' 'e', 'ln(10)', 'ln(2)' 'log10(e)', 'log2(e)'
# used by: 'logx' 'exp'
# 'getConst e 24' returns 'e' truncated to 24 places
getConst(){ 
    case $1 in e|E) dummy=$EE ;; pi|PI) dummy=$PI ;; phi|PHI) dummy=$PHI ;;
        pi_2|PI_2) dummy=$PI_2 ;; pi_4|PI_4) dummy=$PI_4 ;;
        ln10|LN10) dummy=$LN10 ;; l10e|L10E) dummy=$L10E ;;
        ln2|LN2) dummy=$LN2 ;; l2e|L2E) dummy=$L2E ;;
        *) echo "-->getConst: Unknown Constant '$1'" >&2 ; return 1 ;; 
    esac
    [ $2 -ge 32 ] && { echo $dummy ; return ;}
    cout=${dummy%.*}'.' dummy=${dummy#*.}
    while [ ${#cout} -lt $2 ] ;do 
            pmsk=${dummy#*?} cout=$cout${dummy%"$pmsk"*} dummy=$pmsk
    done
    echo $cout
} ## getConst
# cout= dummy= pmsk=

# exp_z -backend for 'exp'
# depends on: 'add' 'mul' 'div'
# used by: 'exp'
# e^x - an implementation of the very fast and precise Pade approximation of e^x found here:
# https://www.omnimaga.org/math-and-science/pade-expansions-for-approximating-the-exponential-function/
# Thanks to Zeda Thomas for this algorithm
## y=x^2
## a=( (x/2) * ( 1 + (5y/156)*( 1 + (3y/550)*( 1 + (y/1512)) )  /  ( 1 + (3y/26)*( 1 + (5y/396)*( 1 + (y/450)) ) )
## e^x = (1+a)/(1-a)
exp_z() { escale=$defprec
    case $1 in -s*) escale=${1#*-s} ; shift ;; ''|-h) exp_help >&2 ; return 1 ;;esac
    e2scale=$escale
    expx=$1
    # y = x^2
    y=$( mul -s$e2scale $expx $expx )
    # halfx = x/2
    halfx=$( div -s$e2scale $expx / 2 )
    
    #nominator = ( 1 + (5y/156)*( 1 + (3y/550))*( 1 + (y/1512)) )
    A=$( div -s$e2scale "$(mul 5 $y)" / 156 )
    B=$( div -s$e2scale "$(mul 3 $y)" / 550 )
    C=$( div -s$e2scale $y / 1512 )
    
    nom=$( add 1 + $C )
    nom=$( mul -s$e2scale $nom $B )
    nom=$( add 1 + $nom )
    nom=$( mul -s$e2scale $nom $A )
    nom=$( add 1 + $nom )
    
    #denominator = ( 1 + (3y/26)*( 1 + (5y/396))*( 1 + (y/450)) )
    X=$( div -s$e2scale "$(mul 3 $y)" / 26 )
    Y=$( div -s$e2scale "$(mul 5 $y)" / 396 )
    Z=$( div -s$e2scale $y / 450 )
    
    denom=$( add 1 + $Z )
    denom=$( mul -s$e2scale $denom $Y)
    denom=$( add 1 + $denom )
    denom=$( mul -s$e2scale $denom $X)
    denom=$( add 1 + $denom )
    # first general ratio
    ratio1=$( div -s$e2scale $nom / $denom )
    # (x/2) * ratio1
    A=$( mul -s$e2scale $ratio1 $halfx )
    
    # e^x = (1+a)/(1-a)
    nom=$( add 1  + $A )
    denom=$( add 1 - $A )
    div -s$escale $nom / $denom
} ## exp_z
## escale= e2scale= expx= y= halfx= A= B= C= nom= X= Y= Z= denom= ratio1=
# operations: 10X mult, 9X div, 8X add

### End back-end functions for pow nroot logx exp

iqxmain="pow nroot logx exp epow "
iqxutil="getConst fpow iqXhelp "

iqXhelp() {
echo "      IQ+ - Version $iqplusversion - Copyright 2023 Gilbert Ashley
    
    iq+ extends the 'iq' calculator, with these functions:
    
    Powers, Roots, Logs: $iqxmain
    iq+ Utilities: $iqxutil
    Trigonometry: $iqtrig
    Trig Utils: $iqtrigutil
    Misc functions: $iqmisc
    Misc functions: $iqmisc2
    
    For help, call a function with null argument or '-h':
    Example: 'iq+ logx -h' or simply: 'iq+ logx'
    
    'pow' is the exponentiation function. 'fpow' and 'epow'
    are backends to 'pow' and for special use cases.
    'logx' returns logs in base 2, 3, 4, 'e/n' or 10
    'nroot' returns the 'nth' root of a decimal number
    'exp' returns 'e^x' Eulers Number to the power of x
    
    Power, Trigonometry and other functions here do not
    support Arbitrary Precision. See any functions' help
    for limits and tips on supported precision.
    To see a complete list of functions pre-loaded by iq+
    Use the command: 'iq+ list'
    "
}

# default for execution block
src=${src:-0}

## Execution block
# If 'iq' and 'iq+' are in your PATH use: 'iq+ command'
# Or temporarily add the location of 'iq' to your PATH, like this:
# PATH=path_to_iq:$PATH iq add 23.43578 7234.45
# Otherwise, 'iq' and 'iq+' must be in the users' current working
# directory and you'd then call iq+ like this: './iq+ command'
if [ "1" != "$src" ]  ; then
    # we don't get here if this file has been sourced: 'src=1 . iq+'
    # iq+ needs to source 'iq' for the main functions
    # for debugging, also handle filenames that have a version number 
    case $0 in 
        ./iq+) src=1 . ./iq 
            . ./iq_trig.sh # uncomment for auto-loading
            . ./iq_misc.sh # uncomment for auto-loading
            #. ./iq_util.sh # uncomment for auto-loading
            #. ./iq_ai.sh   # uncomment for auto-loading
        ;;
        ./iq+?*) vers=${0#*'+'} ; src=1 . ./iq$vers 
            . ./iq_trig$vers # uncomment for auto-loading
            . ./iq_misc$vers # uncomment for auto-loading
            #. ./iq_util$vers # uncomment for auto-loading
            #. ./iq_ai$vers   # uncomment for auto-loading
        ;; 
        *iq+) src=1 . iq 
            . iq_trig.sh # uncomment for auto-loading
            . iq_misc.sh # uncomment for auto-loading
            #. iq_util.sh # uncomment for auto-loading
            #. iq_ai.sh   # uncomment for auto-loading
        ;;
        *iq+?*) vers=${0#*'+'} ; src=1 . iq$vers 
            . iq_trig$vers # uncomment for auto-loading
            . iq_misc$vers # uncomment for auto-loading
            #. iq_util$vers # uncomment for auto-loading
            #. iq_ai$vers   # uncomment for auto-loading
        ;; 
    esac
    # since we are going to do '$cmd "$@"' below, make sure that only our functions
    # can be called, by eliminating the PATH and catching absolute/relative paths
    PATH=
    case $1 in ''|-h|--help) iqXhelp >&2 ; exit ;;
        */*) echo "$0: Improper or dangerous input(a path or command): '$1'" ; exit 1 ;;
    esac
    # this the only place iq+ ever executes something and should only
    # recognize its' own functions. In the functions, command-sustitution is
    # used extensively, but only to run other iq/iq+ functions.
    cmd=$1 ; shift
    $cmd "$@" 
    exit $? 
    # exit status for command-line use like: 'iq+ tsst 1111 -gt 1110 && echo greater'
fi
# end of code

# If you want to use these functions and the normal functions from iq in 
# other shell scripts, simply put these lines into your script like this -without the quotes:
# 'src=1 . ./iq'   -or, as above: 'src=1 . iq'
# 'src=1 . ./iq'   -or, as above: 'src=1 . iq+'
# Or, just source 'iq' and copy the functions you need from iq+ into the body of your script.
# See 'example1.sh' for an example of including functions from 'iq' and 'iq+', etc in your script.

# For more complete instructions, see the bottom lines of 'iq' itself

