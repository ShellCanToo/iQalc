#!/bin/sh
# IQ+/iq+ - Extended version of the iqalc/iq calculator

# Copyright Gilbert Ashley 17 July 2023
# Contact:perceptronic@proton.me  Subject-line: iQalc

# Main functions: pow, nroot, logx, exp, ipow, epow
# Other functions: fpow, getConst, iqXhelp

# disable some style checks and un-helpful suggestions
# shellcheck disable=SC2034,SC2086,SC2295,SC2004,SC1090,SC1091,SC2123,SC2317

iqplusversion=1.80

# trigonometry functions moved to iq_trig
# factorial gcf dec2ratio - moved to iq_misc
# testing with yash found a multibyte superscript character in a comment
# ipow - fix dropping of prec when base is integer -in case exponent is negative
# logx - add factors for base 3 and 4
# logx - increase precision by not truncating early and increasing iterations.
# exp - re-write using new method which increases precision, and add special-case handling
# pow - discard old real, commented method for calculating non-integer exponents
# pow - expanded range of inputs through improvements to logx and exp
# getConst -  return default 30 digits when more is requested
# raise default precision for iq+ from 5 to 6
# autoload iq_trig and iq_misc modules

# default precision 
defprec=${defprec:-6}

# pow - raises a decimal number to a given power
# depends on: 'logx' 'exp' 'ipow' 'fpow' 'mul' 'div'
pow_help() {
echo "   'pow' usage: 'pow [-s?] base [^] exponent'
    
    Raises a number (base) to a power (exponent).
    For integer exponents, 'base' and scale are unlimited.
    Example: 'pow -s9 3.141592 ^ 6' = 961.387993507
    Example: 'pow -s12 12.141592 ^ -6' = 0.000000312137
    
    Fractional exponents are supported, within certain
    ranges, shown roughly below:
    59999.99999 ^ 0.999                     0.99999 ^ 1000009.999
    239.99999 ^ 1.999                       1.09999 ^ 109.999
    35.99999 ^ 2.999    5.99999 ^ 5.999     1.24999 ^ 45.999
    14.99999 ^ 3.999                        1.49999 ^ 26.999
    8.99999 ^ 4.999                         1.99999 ^ 14.999
    
    As seen above, when either 'base' or 'exponent' are <1,
    the allowed range of the other becomes relatively large.
    Above ranges support scales of 6-12, with a slightly wider
    range supporting a reduced scale of 3 less than requested.
    Example: 'pow -s8 7.999999 6.999999'  =  2097145.80409
    
    Execution times increases dramatically when scale is >8.
    " 
}
pow() { scale_pow=$defprec
    case $1 in -s*) scale_pow=${1#*-s} ; shift ;; ''|-h) pow_help >&2 ; return 1 ;;esac
    pbase=$1 ; shift ; case $1 in '^') shift ;;esac
    case $1 in '') pow_help >&2 ; return 1 ;;esac
    pexp=$1 pexpneg='' pbaseneg=''
    # separate and remove neg signs
    case $pbase in '-'*) pbaseneg='-' pbase=${pbase#*?} ;;esac
    case $pexp in '-'*) pexpneg='-' pexp=${pexp#?*} ;;esac
    # separate integer and fractional parts
    case $pbase in .?*) pbase_int=0 pbasefrac=${pbase#*.} ;; *?.?*) pbase_int=${pbase%.*} pbasefrac=${pbase#*.} ;;
        *) pbase_int=$pbase pbasefrac=0 ;;esac
    case $pexp in .?*) pexp_int=0 pexpfrac=${pexp#*.} ;; *?.?*) pexp_int=${pexp%.*} pexpfrac=${pexp#*.} ;;
        *) pexp_int=$pexp pexpfrac=0 ;;esac
    # remove extra leading zeros from integers
    while : ;do case $pbase_int in '0'?*) pbase_int=${pbase_int#?*} ;; *) break ;;esac ;done
    while : ;do case $pexp_int in '0'?*) pexp_int=${pexp_int#?*} ;; *) break ;;esac ;done
    # remove extra trailing zeros from fractions
    while : ;do case $pbasefrac in *?'0') pbasefrac=${pbasefrac%?*} ;; *) break ;;esac ;done
    while : ;do case $pexpfrac in *?'0') pexpfrac=${pexpfrac%?*} ;; *) break ;;esac ;done
    # recombine
    pbase=$pbase_int'.'$pbasefrac  pexp=$pexp_int'.'$pexpfrac
    case "$pbaseneg""$pbase" in
        0.0) case "$pexpneg""$pexp" in -*) echo "-->pow: NaN" >&2 ; return 1 ;;  
                0.0) echo 1.0 ; return ;; *) echo 0.0 ; return ;;esac ;;
        1.0) echo 1.0 ; return ;;
        -*) [ "$pexpfrac" != 0 ] && { echo "-->pow: NaN" >&2 ; return 1 ;}
            [ $((pexp_int%2)) -eq 0 ] && pbaseneg='' ;;
    esac
    case "$pexpneg""$pexp" in
        0.0) echo 0.0 ; return ;; 1.0) echo $pbaseneg$pbase ; return ;;
        -1.0) div -s$scale_pow  1 / $pbaseneg$pbase ; return ;;
    esac
    
    case $pexpfrac in 
        0)  # if exponent is integer, use ipow/epow
            case $pexp_int in 
                1) pres=$pbase_int'.'$pbasefrac ;; # cant get here
                2) pres=$( mul -s$scale_pow $pbase_int'.'$pbasefrac  $pbase_int'.'$pbasefrac ) ;;
                *)  case $pbasefrac in 
                        # both base and exp are integers, so use fpow for 4X faster result
                        0) pres=$( fpow -s$scale_pow $pbase_int'.'$pbasefrac $pexp_int ) ;;
                        # otherwise, use ipow, which will use epow when base<1
                        *) pres=$( ipow -s$scale_pow $pbase_int'.'$pbasefrac $pexp_int ) ;;
                    esac
                ;;
            esac
        ;; 
        *)  # if exponent is non-integer and ln(base)* pexp < 11
            # calculate complex powers using: a^x = e^(x(ln(a))
            case $pexp in
                0.[9876]*) pmed_scale=$((scale_pow+4)) ;;
                0.*) pmed_scale=$((scale_pow+2)) ;;
                *) pbase_int=${pbase%.*} ; pmed_scale=$((scale_pow+4+${#pbase_int})) ;;
            esac
            plog=$( logx -s$pmed_scale n $pbase )
            pprod=$( mul -s$pmed_scale $pexp $plog )
            # this limit is ln(base)* pexp < 11
            rangecheck=${pprod%.*}
            if [ $rangecheck -lt 11 ] ; then
                pres=$( exp -s$pmed_scale $pprod )
            elif [ $rangecheck -lt 15 ] ; then
                # accept wider range but at reduced precision
                pres=$( exp -s$pmed_scale $pprod )
                [ $scale_pow -gt 6 ] && scale_pow=$(( scale_pow -3 ))
            else
                echo "-->pow: 'ln(base) * exponent' must be <15. Your 'ln($pbase) * $expx' = ${pprod%.*}+ \n" >&2 
                pow_help >&2 ; return 1
            fi
        ;;
    esac
    
    # if the exponent is negative, invert the result
    case $pexpneg in '-') pres=$( div -s$scale_pow 1 / $pres ) ;;esac
    # truncate or trim to scale
    case $scale_pow in 0) echo $pbaseneg${pres%.*} ;; 
        *) pfrac=${pres#*.} ; while [ ${#pfrac} -gt $scale_pow ] ;do pfrac=${pfrac%?*} ;done
        echo $pbaseneg${pres%.*}'.'${pfrac:-0} ;; 
    esac

} ## pow
# scale_pow= pbase= pexp= pbaseneg= pexpneg= pbase_int= pbasefrac= pmed_scale=
# plog= pprod= pres= pfrac= rangecheck=

# ipow - raises a decimal number to an integer power
# depends on: 'epow' 'logx' 'mul' 'div'
ipow_help() {
echo "   'ipow' usage: 'ipow [-s?] base [^] exponent'
    
    'base' must be a positive number, integer or decimal.
    Exponents can be negative or positive, but must be integers.
    Example: 'ipow -s20 3.14 ^ -4' = 0.01028682632761480208
    Example: 'ipow -s9  9.35234 16' = 3425504893420641.057301958
    "
}
ipow(){ mp_prec=$defprec
    case $1 in -s*) mp_prec=${1#*-s} ; shift ;; ''|-h) ipow_help >&2 ; return 1 ;;  esac
    basemp=$1 ; shift ; case $1 in '^') shift ;;esac
    case $basemp in '-'*) echo "-->ipow: negative bases not supported: $basemp" >&2 ; return 1 ;;esac
    case $1 in '') ipow_help >&2 ; return 1 ;; 
        *.*) echo "-->ipow: fractional exponents not supported: $1" >&2 ; return 1 ;;
        *) expmp=$1 ;;
    esac
    # store any negation of exponent
    case $expmp in '-'*) expmpneg='-' expmp=${expmp##*-}  ;;esac
    case $basemp in 
        0.*|.*) out_mp=$( epow -S$mp_prec $basemp $expmp )
                case $expmpneg in '-') div -s$mp_prec 1 / $out_mp ;; *) echo $out_mp ;;esac
                return ;;    # use epow for bases less than 1
        *.*) 
            # (log10(base) * exp) + 1 = integer size of result
            logmp=$(logx -s7 10 $basemp)
            mpint_size=$(( $(mul -s0 $logmp $expmp) + 1 ))
            # a reliable minimum scale
            mpmin=$(( ( $expmp + $mpint_size) / 2))
            # plus the requested scale -use a minimum of 5
            [ $mp_prec -lt 5 ] && rec_scale=$(( $mpmin + 5 )) || rec_scale=$(( $mpmin + $mp_prec ))
        ;;
        *) rec_scale=0 ;; # for integer bases, use scale=0 below, but retain mp_prec for negative exponents
    esac
    # do the operation
    out_mp=$basemp
    expmp=$((expmp-1))
    while : ; do
        [ $((expmp%2)) -ne 0 ] && out_mp=$( mul -s$rec_scale $out_mp $basemp ) 
        expmp=$((expmp/2))
        [ $expmp -eq 0 ] && break
        basemp=$( mul -s$rec_scale $basemp $basemp )
    done
    # negative exponent
    case $expmpneg in '-'*) out_mp=$( div -s$mp_prec 1 / $out_mp ) ;;esac
    # format the output
    case $mp_prec in 0) echo ${out_mp%.*} ;;
        *)  out_frac_mp=${out_mp#*.}
            while [ ${#out_frac_mp} -gt $mp_prec ] ; do 
                out_frac_mp=${out_frac_mp%?*}
            done
            echo ${out_mp%.*}'.'$out_frac_mp ;;
    esac
} ## ipow
# mp_prec= basemp= expmp= basemp_frac= maxmp= logmp= mpint_size= 
# mpmin= gr= rec_scale= out_mp= out_frac_mp=

# epow - pow function with answers in normal scale, SigFig scale or e-notation
# depends on: 'logx' 'mul'
# used by: 'ipow' for bases X<1
# example: epow -e6 0.0105 ^ 1000000000 = 1.174730e-1978810701 
epow_help()  {
echo "    'epow' usage: 'epow [-s?,-S,-e?] base [^] exponent' 
    
    Both 'base' and 'exponent' must be positive numbers.
    'base' can be an integer or decimal, 'exponent' must be integer.
    'epow' returns powers with answers in three forms: normally
    scaled outputs, significant digits or scientific notation.
    Output format is controlled with 3 scaling options: -s? -S? or -e?
    
    Example usage for normal scaling: 'epow -s9 0.14 7' = 0.000001054
    Example for significant digits: 'epow -S9 0.14 7' = 0.00000105413504
    Example for scientific notation: 'epow -e9 0.14 7' = 1.05413504e-6
    Example for scientific notation: 'epow -e12 42.818 7' = 2.638667359224e11
    ~2-Billion-digit Example: epow -e6 0.0105 ^ 1000000000 = 1.174730e-1978810701
    "
}
epow() { fstprec=$defprec   # normal scaling             # sigfig scaling
    case $1 in -s*) fstprec=${1#*-s} ; shift ;; -S*) fstprec=${1#*-S}  SigScale=1 ; shift ;;
            # e-notation scaling       
        -e*) fstprec=${1#*-e} E_note=1 ; shift ;; ''|-h) epow_help >&2 ; return 1 ;;
    esac
    SigScale=${SigScale:-0} E_note=${E_note:-0}
    base=$1 ; shift ; case $1 in '^') shift ;;esac
    #case $base in '-'*) epowneg='-'  base=${base#*-} ;;esac
    case $base in '-'*) echo "-->epow: negative base not supported: $basemp" >&2 ; return 1 ;;esac
    case $1 in '-'*) echo "-->epow: Use 'pow' for negative exponents" >&2 ; return 1 ;;
        *.*) echo "-->epow: fractional exponents not supported: $1" >&2 ; return 1 ;;
        '') epow_help >&2 ; return 1 ;;
        *) exp=$1 ;;
    esac
    
    case $E_note in 1) fst_scale=$((fstprec+8)) ;; *) fst_scale=$((exp+fstprec+3)) ;;esac
    # for low scales or exponents over 1,000,000 -we need a small booost...
    [ ${#exp} -gt 7 ] && fst_scale=$(( fst_scale + (${#exp}-7) ))
    [ $fstprec -lt 7 ] && fst_scale=$(( fst_scale + 2 ))
    case $base in 
        0.0*|.0*) zeros=0 dummy=${base#*.}  # remove and count leading zeros
            while : ; do case $dummy in 0*) dummy=${dummy#*?} zeros=$((zeros+1)) ;; *) break ;;esac ; done
            # take the log of the rest
            bplog=$(logx -s7 10 '.'$dummy )
            # multiply the absolute value of the log by the exponent to determine the length of growth
            E=$(mul -s0 ${bplog#*-} $exp )
            # add in the leading zeros, which are (zeros * exp) and add back the sign
            E=$((E + (zeros*exp) )) E='-'$E ;;
        0.*|.*)     # like above, but without leading zeros in the base
            bplog=$(logx -s7 10 $base ) E=$(mul -s0 ${bplog#*-} $exp ) E='-'$E ;;
            #bplog=$(logx -s10 10 $base ) E=$(mul -s0 ${bplog#*-} $exp ) E='-'$E ;;
        *)  # integers need a '0' fraction which is later removed
            bplog=$(logx -s7 10 $base ) E=$(mul -s0 $exp $bplog)
            case $base in 
                *.*) #base_int=${base%.*} base_int_size=${#base_int}
                    [ 0 = "$E_note" ] && fst_scale=$(( E + fstprec + 5 )) ;; 
                *) base=$base'.0' is_int=1 ;;
            esac
            base='.'${base%.*}${base#*.} ;;
    esac
    
    # do the operation -everything has been made into a fraction
    # keep only the significant digits after each multiplication
    out_pm=$base
    exp=$((exp - 1))
    while : ; do 
        if [ $((exp%2)) -ne 0 ] ; then
            out_pm=$( mul -s$fst_scale $out_pm $base ) 
            dummy=${out_pm#*.}
            while : ; do case $dummy in 0*) dummy=${dummy#*?} ;; *) break ;;esac ; done
            out_pm='0.'$dummy
        fi
        exp=$((exp/2))
        [ $exp -eq 0 ] && break
        base=$( mul -s$fst_scale $base $base )
        dummy=${base#*.}
        while : ; do case $dummy in 0*) dummy=${dummy#*?} ;; *) break ;;esac ; done
        base='0.'$dummy
    done
    
    # reconstruct the output
    if [ 1 = "$E_note" ] ; then
        case $E in -*) E=$((E-1)) ;;esac
        dummy=${out_pm#*.}  # remove the extra 8, unless fraction has terminated
        [ ${#dummy} -gt $fst_scale ] && dummy=${dummy%???????*}
        msk1=${dummy#*?} out_pm=${dummy%$msk1*}
        while [ ${#msk1} -gt $fstprec ] ; do msk1=${msk1%?*} ; done
        echo $out_pm'.'${msk1:-0}'e'$E
    else
        case $E in 
            -*) cnt_p=0 pad='' E_abs=${E#*-}
                while [ $cnt_p -lt $E_abs ] ; do pad=$pad'0' cnt_p=$((cnt_p+1)); done
                cnt_p=0 dummy=$pad${out_pm#*.} out_pm=''
                case $SigScale in 1) fstprec=$(( $E_abs + fstprec )) 
                        while [ ${#dummy} -gt $fstprec ] ; do dummy=${dummy%?*} ; done
                        out_pm=$dummy
                    ;;
                    *)  while [ $cnt_p -lt $fstprec ] ; do 
                            cnt_p=$((cnt_p+1)) msk1=${dummy#*?} out_pm=$out_pm${dummy%$msk1*} dummy=$msk1
                        done ;;
                esac
                out_pm='0.'$out_pm
            ;;
            *)  dummy=${out_pm#*.}  # trim off extra unless input was integer or fraction terminates at shorter length
                [ 1 != "$is_int" ] && [ ${#dummy} -gt $fst_scale ] && dummy=${dummy%???*}
                cnt_p=-1 out_pm=''
                while [ $cnt_p -lt $E ] ; do 
                    cnt_p=$((cnt_p+1)) msk1=${dummy#*?} out_pm=$out_pm${dummy%$msk1*} dummy=$msk1
                done
                cnt_p=0 zeros=0 out_frac=''
                case $SigScale in 1) scratch=$dummy
                    while : ; do case $scratch in 0*) zeros=$((zeros+1)) scratch=${scratch#*?} ;; *) break ;;esac ; done
                esac
                fstprec=$((fstprec+zeros))
                while [ $cnt_p -lt $fstprec ] ; do 
                    cnt_p=$((cnt_p+1)) msk1=${dummy#*?} out_frac=$out_frac${dummy%$msk1*} dummy=$msk1
                done
                out_pm=$out_pm'.'${out_frac:-0}
            ;;
        esac
        [ 1 = "$is_int" ] && echo ${out_pm%.*} || echo $out_pm
    fi
} ## epow
# fstprec= SigScale= E_note= base= exp= fst_scale= zeros= dummy= bplog= E= base_int= base_int_size= out_pm=
# msk1= cnt_p= scratch= out_frac

# nroot - find the 'n-th' root of a number
# depends on: 'nrt_solv' 'div'
nroot_help() {
echo "   'nroot' usage: 'nroot [-s?] Number Nth'
    
    'Number' must be a positive integer or decimal
    'Nth' must be a positive integer
    Example: 'nroot -s6 4.3 10' for: 10th root of 4.3
    Example: 'nroot -s8 43.225 2' for: sqrt of 43.225
    Example: 'nroot -s12 2 2' = 1.414213562373
    "
}
nroot() { scale_nrt=$defprec
    case $1 in -s*) scale_nrt=${1#*-s} ; shift ;; ''|-h) nroot_help >&2 ; return 1  ;;esac
    case $2 in '') nroot_help >&2 ; return 1  ;; 
        *.*) echo "-->nroot: Nth must be an integer" >&2 ; return 1 ;; 
    esac
    base_nrt=$1 N_th=$2 # get the inputs
    case $N_th in '-'*) Nth_neg='-' N_th=${N_th#*-} ;; esac # separate neg from nth
    while : ; do case $N_th in 0?*) N_th=${N_th#*?} ;; *) break ;; esac ; done # depad nth
    case $base_nrt in '-'*) nrt_neg='-' base_nrt=${base_nrt#*-} ;; esac # separate neg from base
    case $base_nrt in 0.*|.*) nrt_int=0 nrt_frac=${base_nrt#*.} ;; # separate base int and frac
        *.*) nrt_int=${base_nrt%.*} nrt_frac=${base_nrt#*.} ;; *) nrt_int=$base_nrt nrt_frac=0 ;;
    esac
    while : ; do case $nrt_int in 0?*) nrt_int=${nrt_int#*?} ;; *) break ;; esac ; done # depad base int
    while : ; do case $nrt_frac in *?0) nrt_frac=${nrt_frac%?*} ;; *) break ;; esac ; done # depad base frac
    base_nrt=$nrt_int'.'$nrt_frac
    # handle special cases
    case $nrt_neg$base_nrt in
        0.0) case "$Nth_neg""$N_th" in -*) echo "-->nroot: NaN" >&2 ; return 1 ;;  
                0) echo 1.0 ; return ;; *) echo 0.0 ; return ;;esac ;;
        1.0) echo 1.0 ; return ;;
        -*) [ $((N_th%2)) -eq 0 ] && { echo "-->nroot: NaN" >&2 ; return 1 ;} ;;
    esac
    case $Nth_neg$N_th in
        0) echo 0.0 ; return ;; 1) echo $nrt_neg$base_nrt ; return ;;
        -1) div -s$scale_nrt  1 / $nrt_neg$base_nrt ; return ;;
    esac
    # If we get here, do scale-compensation for small bases, or user requests scale=0
    if [ $scale_nrt -eq 0 ] ; then
        scale_nthrt=2
    else
        # a complete solution for bases <0.0?* would mean counting leading zeros, but let's try this
        case $base_nrt in 0.0*) scale_nthrt=$(( (scale_nrt*12) / 10 )) ;; *) scale_nthrt=$scale_nrt ;; esac
    fi
    # for Nth which are multiples of 10, break into chunks
    if [ $((N_th % 10)) -eq 0 ] ; then
        while [ $N_th -gt 9 ] ;do
            N_th=$((N_th / 10))
            base_nrt=$(nrt_solv -s$scale_nthrt $base_nrt 10 )
        done
        [ $N_th -gt 1 ] && base_nrt=$(nrt_solv -s$scale_nthrt $base_nrt $N_th )
    else
        # otherwise use the longer method
        if [ $N_th -gt 9 ] ; then
            solved=0 # try using factors
            for try in 9 8 7 6 5 4 3 2 ;do
                if [ $((N_th % try)) -eq 0 ] ; then
                    N_th=$((N_th / try))
                    base_nrt=$(nrt_solv -s$scale_nthrt $base_nrt $try )
                    base_nrt=$(nrt_solv -s$scale_nthrt $base_nrt $N_th )
                    solved=1 ; break
                fi
            done
            # number is prime or its' smallest factor is >9
            [ 0 = "$solved" ] && base_nrt=$( nrt_solv -s$scale_nthrt $base_nrt $N_th )
        else
            # for small N_th
            base_nrt=$( nrt_solv -s$scale_nthrt $base_nrt $N_th )
        fi
    fi
    case $Nth_neg in '-') base_nrt=$( div -s$scale_nthrt 1 / $base_nrt ) ;; esac
    # messy(still) decomposition of intermediate scales and output
    case $scale_nthrt in "$scale_nrt") echo $nrt_neg$base_nrt ;; 
        *)  case $scale_nrt in 0) echo $nrt_neg${base_nrt%.*} ;;
                *)  nrt_frac=${base_nrt#*.} nrt_out_frac=
                    while [ ${#nrt_out_frac} -lt $scale_nrt ] ; do   
                        nrt_msk=${nrt_frac#*?} nrt_out_frac=$nrt_out_frac${nrt_frac%$nrt_msk*} nrt_frac=$nrt_msk
                    done
                    echo $nrt_neg${base_nrt%.*}'.'$nrt_out_frac ;;
            esac ;;
    esac
    
} ## nroot -s7 4.2 5 (for 5th root of 4.2)
# scale_nthrt= N_th= base_nrt= solved=

# logx - returns logarithms in base 10, e/n or 2
# depends on: 'getConst' 'tsst' 'mul' 'div' 'add'
# This uses a fast approximation with very good precision
# uses a power series for ln(x) and then converts to base 2 or 10 if needed
# ln(x) = 2{ (x-1/x+1) + 1/3(x-1/x+1)^3 + 1/5(x-1/x+1)^5 + ...}
logx_help() {
echo "    'logx' usage: 'logx [-s?] base number'
    
    Calculates logarithms in base n/e, 2, 3, 4, or 10
    Example log base10: 'logx -s8 10 6.7' for: log(6.7)
    Example log base natural: 'logx -s7 n 6.7' for: ln(6.7)
    Example log base2: 'logx -s7 2 6.7' for: log2(6.7)
    
    Accuracy is at least 20 Decimal places.
    Execution times increase greatly when scale>=14.
   "
}
logx() { scale_lx=$defprec
    case $1 in -s*) scale_lx=${1#*-s} ; shift ;; ''|-h) logx_help >&2 ; return 1 ;;esac
    case $2 in '') logx_help >&2 ; return 1 ;;esac
    base=$1 x=$2 # special cases and errors
    case $x in # input errors and logx(1) are universal for all bases
        -*) echo "-->logx: NaN" >&2 ; return 1 ;;
        0|0.0) echo "-->logx: NaN" >&2 ; return 1 ;; 
        1|1.0) echo 0.0 ; return ;;
    esac
    case $base in # base-specific errors and easy-outs
        10) # log10 easy outs - different for other bases
            case $x in 
                0.1|.1) echo '-1' ; return ;; 10|10.0) echo 1 ; return ;; 10'.'*) : ;;
                10*)  mask=${x#?*} ; tsst $mask -eq 0 && { echo ${#mask}'.0' ; return ;} ;;
                .0*|0.0*) frac=${x#*.} 
                    # possible 10^-n, if so: 0.01, 0.001, ..., return -1, -2, ...
                    tsst ${frac%1*} -eq 0  && { echo '-'${#frac}'.0' ; return ;} ;;
            esac ;; 
        [234ne]) : ;;
        *) echo "-->logx: False base input: e, n, 2, 3, 4 or 10 allowed" >&2 ; return 1 ;;
    esac
    # set the internal scale, then determine the characteristic, here called 'rank'
    e_scale=$(($scale_lx+2))
    lxE=$(getConst e $e_scale)
    rank=0
    # bring x into range, if needed
    while tsst $x -lt .4 ;do rank=$((rank-1)) x=$( mul -s$e_scale $x $lxE ) ;done
    while tsst $x -gt 2.8 ;do rank=$((rank+1)) x=$( div -s$e_scale $x / $lxE ) ;done
    
    its=$((scale_lx+3))    # set the max number of iterations
    case $x in 0.0*) echo "-->logx: how did we get here?" >&2 ; return 1 ;; # this happens when called incorrectly
        0.1*|0.2*) e_scale=$((scale_lx+6)) its=$(($scale_lx+6)) ;; 
        1.0*) d=${x#*.} z=0 ; while : ;do case $d in 0*) z=$((z+1)) d=${d#?*} ;; *) break ;;esac ;done
            e_scale=$((scale_lx+z+2)) ;;
    esac
    
    # get the initial ratio of (x-1/x+1) and initialize acu and total 
    x_m=$( add $x - 1 )         x_p=$( add $x + 1 )
    ratio=$( div -s$e_scale $x_m / $x_p )   total=$ratio acu=$ratio lxcnt=0 dvsr_series=3
    
    # do the iterations  (x-1/x+1)^3/3 ... (x-1/x+1)^5/5 ... (x-1/x+1)^7/7
    while [ $lxcnt -lt $its ] ;do
        # must multiply by ratio twice to preserve sign of reults
        acu=$( mul -s$e_scale $acu $ratio )    acu=$( mul -s$e_scale $acu $ratio )
        tsst ${acu#*-} -eq 0 && break
        sub_total=$( div -s$e_scale $acu / $dvsr_series ) total=$( add $total $sub_total )
        lxcnt=$((lxcnt+1)) dvsr_series=$((dvsr_series+2))
    done
    lxout=$( mul -s$e_scale $total 2 )
    # print or convert the output according to the base
    case $base in e|n) add -s$scale_lx $rank $lxout ; return  ;;
        *) lxout=$( add $lxout $rank ) ;;
    esac
    # factors derived by this formula: factor = 1 / ln(new-base)
    case $base in
        10) mul -s$scale_lx $lxout 0.43429448190325182765 ;; #11289 ;; # 2.3025850929940456840179915
        2) mul -s$scale_lx $lxout 1.44269504088896340735 ;; # 99246 ;; # 0.69314718055994530941723212
        3) mul -s$scale_lx $lxout 0.91023922662683739361 ;; # 444335   # 1.098612288668109691395
        4) mul -s$scale_lx $lxout 0.72134752044448171348 ;; # 1.3862943611198906
    esac
} ## logx
# scale_lx= base= x= mask= frac= e_scale= rank= lxE= its= d= z= x_m= x_p= 
# ratio= total= lxcnt= dvsr_series= acu= sub_total= lxout=

# exp - e^x - Eulers' number 'e' raised to 'x'
# depends on: 'exp_z' 'tsst' 'add' 'mul
# depends on: 'exp_z' 'tsst' 'add' 'mul
# precision is tuned to provide ~12 places for a wide range of inputs,
# where X<19 -tested down to ~X>0.00000002
exp_help() {
echo "    'exp' usage: 'exp [-s?] exponent'
    
    'e^x' - raises Euler's number 'e' to a given power 'x' (e^x),
    Example: 'exp -s15 3.6' returns: '36.598234443677978'
    Example: 'exp -s8 1.134' returns: '3.10806392'
    Accurate to ~12 places where X<19.0, ~6 places where X=19-29,
    and ~3 places where X=29-35. 
    "
}
exp() { escale=$defprec
    case $1 in -s*) escale=${1#*-s} ; shift ;; ''|-h) exp_help >&2 ; return 1 ;;esac
    case $1 in '') exp_help >&2 ; return 1 ;; *) expx=$1 ;;esac
    expneg=''
    case $expx in '-'*) expneg='-'  expx=${expx#*-} ;;esac
    
    # special cases for early exit
    case ${expneg}${expx} in
        0|0.0) echo 1.0 ; return ;;
        1|1.0) getConst E $escale ; return ;;
        -1|-1.0) div -s$escale 1 / $( getConst E $escale ) ; return ;;
    esac
    
    e2scale=$((escale+2))
    rangecheck=${expx%.*}
    if [ $rangecheck -gt 35 ] ; then
        echo "--> exp: Input '$expx' is out of range, must be <35 " >&2
        return 1
    elif [ $rangecheck -gt 29 ] ; then
        e2scale=$((escale+15))
        escale=6
    elif [ $rangecheck -gt 19 ] ; then
        e2scale=$((escale+10))
        [ $escale -gt 3 ] && escale=$((escale-3))
    fi
    
    # ln(10) = 2.30258509299404568401 7991454684
    ln10=2.30258509299404568401
    #ln10=$( getConst LN10 $(($e2scale+2)) )
    # argument reduction
    # using limits of 1.1 gives us ~12 places of precision
    if tsst $expx -gt 1.1 ; then
        pad='1' ; cnt=0
        #while tsst $expx -gt 1.1 ; do
        #    expx=$( add $expx - $ln10 ) 
        #    pad=$pad'0'
        #done
        qr=$( div -s$e2scale $expx qr $ln10 )
        mag=${qr% *} expx=${qr#*' '}
        while [ $cnt -lt ${mag%.*} ] ; do pad=$pad'0' ; cnt=$((cnt+1))  ; done
        
        expout=$( exp_z -s$e2scale $expx )
        case $expneg in '-') div -s$escale 1 / $( mul -s$e2scale $expout $pad ) ;; 
            *) mul -s$escale $expout $pad ;; 
        esac
    else
        case $expneg in '-') div -s$escale 1 /$( exp_z -s$e2scale $expx )  ;; 
            *) exp_z -s$escale $expx ;;
        esac
    fi
} ## exp
# e^-x = 10-0.43429448190325x  log10(e)=0.434294481903251827651128917

### Back-end functions for pow nroot log
# fpow is used by: nrt_solv
# depends on: 'mul' 
# Don't call this directly unless you know how to use it
fpow() { case $1 in -s*) fstprec=${1#*-s} ; shift ;; *) fstprec=$defprec ;;esac
    case $1 in -t*) truncprec=${1#*-t} ; shift ;; *) truncprec='' ;;esac
    base_fst=$1
    # these conditions shouldn't really happen here, but just in case:
    case $2 in 0) echo 1.0 ; return ;; 1) echo $base_fst ; return ;;
        2) mul -s$fstprec $base_fst $base_fst  ; return ;;
    esac
    
    out_fst=$1
    exp_fst=$(( $2 - 1 ))
    while : ; do
        [ $((exp_fst%2)) -ne 0 ] && out_fst=$( mul -s$fstprec $out_fst $base_fst )
        exp_fst=$((exp_fst/2))
        [ $exp_fst -eq 0 ] && break
        base_fst=$( mul -s$fstprec $base_fst $base_fst )
    done
    
    case $truncprec in '') echo $out_fst;;
        *) case $out_fst in *.*) fstfrac=${out_fst#*.} 
            while [ ${#fstfrac} -gt $truncprec ] ; do fstfrac=${fstfrac%?*} ; done
            echo ${out_fst%.*}'.'$fstfrac ;;
            *) echo $out_fst ;;esac ;;
    esac
} ## fpow
# fstprec= base_fst= exp_fst= out_fst=

# nrt_solv -backend root solver for 'nroot'
# depends on: 'cmp3w' 'fpow' 'tsst'
# Don't call this directly unless you know how to use it
nrt_solv() { case $1 in -s*) nthrtsprec=${1#*-s} ; shift ;; *) nthrtsprec=$defprec ;;esac
    goal=$1 goal_int=${1%.*} goal_nth=$2
    # get the integer part of the answer
    answ_int='' this_nth=5 
    if [ "${goal_int:-0}" = 0 ] ; then
        answ_int=0
    else
        case $goal_int in 1|2|3) answ_int=1 answ_size=1 ;;
                *) while : ;do    # get size of answers' integer and pad-up columns if needed
                        case $( cmp3w "$( fpow -s0 '1'"$col" $goal_nth )" $goal_int ) in
                            '>') answ_size=${#col} col=${col%?*} ; break ;;esac
                        col=$col'0'
                    done ; answ_int='' ;;
        esac
        # search order for integer part: 5,9,7 - 5,1,3
        while : ;do
            this_product=$( fpow -s0 "$answ_int""$this_nth""$col" $goal_nth )
            signal=$( cmp3w $this_product $goal_int )
            [ $signal = "=" ] && { answ_int="$answ_int""$this_nth""$col" ; break ;}
            case $this_nth in
            '9') case $signal in '<') answ_int=$answ_int'9' this_nth=5 col=${col%?*} ;; '>') this_nth=7 ;;esac ;;
            '8') case $signal in '<') answ_int=$answ_int'8' this_nth=5 col=${col%?*} ;;
                                '>') answ_int=$answ_int'7' this_nth=5 col=${col%?*} ;;esac ;;
            '7') case $signal in '<') this_nth=8 ;; '>') this_nth=6 ;;esac ;;
            '6') case $signal in '<') answ_int=$answ_int'6' this_nth=5 col=${col%?*} ;; 
                                '>') answ_int=$answ_int'5' this_nth=5 col=${col%?*} ;;esac ;;
            '5') case $signal in '<') this_nth=9 ;; '>') this_nth=1 ;;esac ;;
            '4') case $signal in '<') answ_int=$answ_int'4' this_nth=5 col=${col%?*} ;;
                                '>') answ_int=$answ_int'3' this_nth=5 col=${col%?*} ;;esac ;;
            '3') case $signal in '>') this_nth=2 ;; '<') this_nth=4  ;;esac ;;
            '2') case $signal in '>') answ_int=$answ_int'1' this_nth=5 col=${col%?*} ;; 
                                '<') answ_int=$answ_int'2' this_nth=5 col=${col%?*} ;;esac ;;
            '1') case $signal in '>') answ_int=$answ_int'0' this_nth=5 col=${col%?*} ;; '<') this_nth=3 ;;esac ;;
            esac
            [ ${#answ_int} -eq $answ_size ] && break
        done
        # early exit if we already have the answer
        if tsst $this_product -eq $goal ; then
            case $nthrtsprec in 0) echo ${answ_int%.*} ;; *)  echo "${answ_int%.*}"".0" ;;esac
            return
        fi
    fi
    # do the fractional part
    answ_frac=''  answ_int=$answ_int'.' 
    # set a conservative scale for fpow to assure valid results
    fpow_scale=$(( (nthrtsprec * 13) / 10 ))
    this_nth=5 nthrtrunc=$((nthrtsprec+1))
    # Search order for fractional parts is: 5,9,7  5,3,1(was 5,1,3)
    while : ;do
        this_product=$( fpow -s$fpow_scale -t$nthrtrunc "$answ_int""$answ_frac""$this_nth" $goal_nth )
        signal=$( cmp3w $this_product $goal ) 
        [ $signal = "=" ] && { answ_frac="$answ_frac""$this_nth" ; break ;}
        case $this_nth in
            '1') case $signal in '<') this_nth=2 ;; '>') answ_frac=$answ_frac'0' this_nth=5 ;;esac ;;
            '2') case $signal in '<') answ_frac=$answ_frac'2' this_nth=5 ;; '>') answ_frac=$answ_frac'1' this_nth=5 ;;esac ;;
            '3') case $signal in '<') this_nth=4 ;; '>') this_nth=1 ;;esac ;;
            '4') case $signal in '<') answ_frac=$answ_frac'4' this_nth=5 ;; '>') answ_frac=$answ_frac'3' this_nth=5 ;;esac ;;
            '5') case $signal in '<') this_nth=9 ;; '>') this_nth=3 ;;esac ;;
            '6') case $signal in '<') answ_frac=$answ_frac'6' this_nth=5 ;; '>') answ_frac=$answ_frac'5' this_nth=5 ;;esac ;;
            '7') case $signal in '<') this_nth=8 ;; '>') this_nth=6 ;;esac ;;
            '8') case $signal in '<') answ_frac=$answ_frac'8' this_nth=5 ;; '>') answ_frac=$answ_frac'7' this_nth=5 ;;esac ;;
            '9') case $signal in '<') answ_frac=$answ_frac'9' this_nth=5 ;; '>') this_nth=7 ;;esac ;;
        esac
        [ ${#answ_frac} -eq $nthrtsprec ] && break 
    done
    # format output as needed
    case $nthrtsprec in 0) echo ${answ_int%.*} ;;
        *)  while [ ${#answ_frac} -gt $nthrtsprec ] ;do answ_frac=${answ_frac%?*} ;done
            echo ${answ_int%.*}'.'$answ_frac ;;
    esac
} ## nrt_solv
# nthrtsprec= goal_nth= goal= goal_int= answ_int= col= answ_size= this_nth= this_product= signal= answ_frac= nthrtrunc=

# getConst - returns a truncated constant 'e', 'pi', 'ln(10)', 'pi/2', 'pi/4' or 'phi'
# used by: 'logx'
# 'getConst e 24' returns 'e' truncated to 24 places
# 'getConst e' alone returns 'e' to 11 places
EE=2.718281828459045235360287471352
ee=2.71828182845904523536
e=2.718281828459045
LN10=2.302585092994045684017991454684
ln10=2.302585092994045
# log10(e) = 0.434294481903251827651128917
PI=3.141592653589793238462643383279
pi=3.141592653589793
PI_2=1.570796326794896619231321691639
pi_2=1.570796326794896
PI_4=0.785398163397448309615660845819
pi_4=0.785398163397448
PHI=1.618033988749894848204586834365
phi=1.618033988749894
getConst(){ 
    case $1 in e|E) dummy=$EE short=$ee ;; pi|PI) dummy=$PI short=$pi ;;
        pi_2|PI_2) dummy=$PI_2 short=$pi_2 ;; pi_4|PI_4) dummy=$PI_4 short=$pi_4 ;;
        phi|PHI) dummy=$PHI short=$phi ;; ln10|LN10) dummy=$LN10 short=$ln10 ;;
        *) echo "-->getConst: Unknown Constant '$1'" >&2 ; return 1 ;; 
    esac
    case $2 in ?*) pcnt=-2 cout='' 
        #[ $2 -gt 30 ] && { echo "-->getConst: Constant length fixed at 30" >&2 ; echo $dummy ; return ;}
        [ $2 -gt 30 ] && { echo $dummy ; return ;}
        while [ $pcnt -lt $2 ] ;do 
            pmsk=${dummy#*?} cout=$cout${dummy%$pmsk*} dummy=$pmsk pcnt=$((pcnt+1))
        done
        echo $cout ;; 
        *)  case $1 in E|P?*|L?*) echo $dummy ;; *) echo $short ;;esac;;
    esac
} ## getConst
# pcnt= cout= dummy= pmsk= short=

# exp_z -backend for 'exp'
# depends on: 'add' 'mul' 'div'
# used by: 'exp'
# e^x - an implementation of the very fast and precise Pade approximation of e^x found here:
# https://www.omnimaga.org/math-and-science/pade-expansions-for-approximating-the-exponential-function/
# Thanks to Zeda Thomas for this algorithm - translated here from assembly to shell
## y=x^2
## a=( (x/2) * ( 1 + (5y/156)*( 1 + (3y/550)*( 1 + (y/1512)) )  /  ( 1 + (3y/26)*( 1 + (5y/396)*( 1 + (y/450)) ) )
## e^x = (1+a)/(1-a)
exp_z() { escale=$defprec
    case $1 in -s*) escale=${1#*-s} ; shift ;; ''|-h) exp_help >&2 ; return 1 ;;esac
    e2scale=$((escale+1))
    expx=$1
    # y = x^2
    y=$( mul -s$e2scale $expx $expx )
    # halfx = x/2
    halfx=$( div -s$e2scale $expx / 2 )
    
    #nom=( 1 + (5y/156)*( 1 + (3y/550))*( 1 + (y/1512)) )
    A=$( div -s$e2scale "$(mul 5 $y)" / 156 )
    B=$( div -s$e2scale "$(mul 3 $y)" / 550 )
    C=$( div -s$e2scale $y / 1512 )
    nom=$( add 1 + $C )
    nom=$( mul -s$e2scale $nom $B)
    nom=$( add 1 + $nom )
    nom=$( mul -s$e2scale $nom $A)
    nom=$( add 1 + $nom )
    
    #denom = ( 1 + (3y/26)*( 1 + (5y/396))*( 1 + (y/450)) )
    X=$( div -s$e2scale "$(mul 3 $y)" / 26 )
    Y=$( div -s$e2scale "$(mul 5 $y)" / 396 )
    Z=$( div -s$e2scale $y / 450 )
    denom=$( add 1 + $Z )
    denom=$( mul -s$e2scale $denom $Y)
    denom=$( add 1 + $denom )
    denom=$( mul -s$e2scale $denom $X)
    denom=$( add 1 + $denom )
    
    # first general ratio
    ratio1=$( div -s$e2scale $nom / $denom )
    # (x/2) * ratio1
    A=$( mul -s$e2scale $ratio1 $halfx )
    
    # e^x = (1+a)/(1-a)
    nom=$( add 1  + $A )
    denom=$( add 1 - $A )
    div -s$escale $nom / $denom
} ## exp_z
## escale= e2scale= expx= y= halfx= A= B= C= nom= X= Y= Z= denom= ratio1=
# operations: 10X mult, 9X div, 8X add

### End back-end functions for pow nroot logx exp

iqxmain="pow nroot logx exp ipow epow "
iqxutil="getConst fpow iqXhelp "

iqXhelp() {
echo "      IQ+ - Version $iqplusversion - Copyright 2023 Gilbert Ashley
    
    iq+ extends the 'iq' calculator, with these functions:
    
    Powers, Roots, Logs: $iqxmain
    iq+ Utilities: $iqxutil
    Trigonometry: $iqtrig
    Trig Utils: $iqtrigutil
    Misc functions: $iqmisc
    Misc functions: $iqmisc2
    
    For help, call a function with null argument or '-h':
    Example: 'iq+ logx -h' or simply: 'iq+ logx'
    
    'pow' is the main power function. 'ipow' and 'epow'
    are backends to 'pow' and for special use cases.
    'logx' returns logs in base 2, 3, 4, 'e/n' or 10
    'nroot' returns the 'nth' root of a decimal number
    'exp' returns 'e^x' Eulers Number to the power of x
    
    Power, Trigonometry and other functions here do not
    support Arbitrary Precision. See any functions' help
    for limits and tips on supported precision.
    To see a complete list of functions pre-loaded by iq+
    Use the command: 'iq+ list'
    "
}

# default for execution block
src=${src:-0}

## Execution block
# If 'iq' and 'iq+' are in your PATH use: 'iq+ command'
# Or temporarily add the location of 'iq' to your PATH, like this:
# PATH=path_to_iq:$PATH iq add 23.43578 7234.45
# Otherwise, 'iq' and 'iq+' must be in the users' current working
# directory and you'd then call iq+ like this: './iq+ command'
if [ "1" != "$src" ]  ; then
    # we don't get here if this file has been sourced: 'src=1 . iq+'
    # iq+ needs to source 'iq' for the main functions
    # for debugging, also handle filenames that have a version number 
    case $0 in 
        ./iq+) src=1 . ./iq 
            . ./iq_trig.sh # uncomment for auto-loading
            . ./iq_misc.sh # uncomment for auto-loading
            #. ./iq_util.sh # uncomment for auto-loading
            #. ./iq_ai.sh   # uncomment for auto-loading
        ;;
        ./iq+?*) vers=${0#*'+'} ; src=1 . ./iq$vers 
            . ./iq_trig$vers # uncomment for auto-loading
            . ./iq_misc$vers # uncomment for auto-loading
            #. ./iq_util$vers # uncomment for auto-loading
            #. ./iq_ai$vers   # uncomment for auto-loading
        ;; 
        *iq+) src=1 . iq 
            . iq_trig.sh # uncomment for auto-loading
            . iq_misc.sh # uncomment for auto-loading
            #. iq_util.sh # uncomment for auto-loading
            #. iq_ai.sh   # uncomment for auto-loading
        ;;
        *iq+?*) vers=${0#*'+'} ; src=1 . iq$vers 
            . iq_trig$vers # uncomment for auto-loading
            . iq_misc$vers # uncomment for auto-loading
            #. iq_util$vers # uncomment for auto-loading
            #. iq_ai$vers   # uncomment for auto-loading
        ;; 
    esac
    # since we are going to do '$cmd "$@"' below, make sure that only our functions
    # can be called, by eliminating the PATH and catching absolute/relative paths
    PATH=
    case $1 in ''|-h|--help) iqXhelp >&2 ; exit ;;
        */*) echo "$0: Improper or dangerous input(a path or command): '$1'" ; exit 1 ;;
    esac
    # this the only place iq+ ever executes something and should only
    # recognize its' own functions. In the functions, command-sustitution is
    # used extensively, but only to run other iq/iq+ functions.
    cmd=$1 ; shift
    $cmd "$@" 
    exit $? 
    # exit status for command-line use like: 'iq+ tsst 1111 -gt 1110 && echo greater'
fi
# end of code

# If you want to use these functions and the normal functions from iq in 
# other shell scripts, simply put these lines into your script like this -without the quotes:
# 'src=1 . ./iq'   -or, as above: 'src=1 . iq'
# 'src=1 . ./iq'   -or, as above: 'src=1 . iq+'
# Or, just source 'iq' and copy the functions you need from iq+ into the body of your script.
# See 'example1.sh' for an example of including functions from 'iq' and 'iq+', etc in your script.

# For more complete instructions, see the bottom lines of 'iq' itself

