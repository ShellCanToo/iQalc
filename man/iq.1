.\" Automatically generated by Pandoc 2.9.2.1
.\"
.TH "IQ" "1" "" "Version 2.0" "IQ Calculator Documentation"
.hy
.SH NAME
.PP
\f[B]iq\f[R] An arbitrary precision decimal calculator
.SH SYNOPSIS
.PP
\f[B]iq\f[R] func_name [-s?] number1 operator number2
.PP
\f[B]iq\f[R] func_name [\f[B]-h\f[R]]
.PP
\f[B]iq\f[R] [\f[B]-h\f[R]|\f[B]\[en]help\f[R]]
.PP
\f[B]iq\f[R] \f[B]-i\f[R]
.SH DESCRIPTION
.PP
\f[B]IQ\f[R] is an arbitrary precision decimal calculator, which
performs the Basic Math operations of Addition, Subtraction,
Multiplication, Division, Remainder, Modulo, Numeric-comparison and
Rounding.
.PP
\f[I]iq\f[R] can be run interactively or used as a one-shot command-line
calculator.
And, it can be `sourced' into the shell environment for `on-line' use.
\f[I]iq\f[R] was designed especially to replace other CLI calculators in
shell scripts where precision math and good performance is needed.
.PP
The Basic operations are also the basis for several extensions or
modules.
They perform more complex operations or mathematical functions, like
powers, roots, logarithms, trigonometry, calculus or neural-networking.
.PP
More than 60 functions are available, grouped into 5 Modules.
Each module depends only on the \f[B]IQ\f[R] Basic Math operations, so
there are no complex inter-dependencies.
.SS OPTIONS
.PP
-h, \[en]help
.IP
.nf
\f[C]
Prints general usage information
\f[R]
.fi
.PP
-i
.IP
.nf
\f[C]
Runs \[aq]iq\[aq] in Interactive Mode
\f[R]
.fi
.PP
list
.IP
.nf
\f[C]
Prints a list of avialable functions
\f[R]
.fi
.SS NUMBERS
.PP
Input numbers can be integers or decimal numbers of nearly any length.
Maximum number length is limited by the shells\[cq] maximum variable
length.
.PP
Inputs and outputs are in normal decimal notation:
.PP
1726 -1726 1726.34869 -1726.5736
.PP
Maximum number length is equal to the shells\[cq] maximum variable
length.
.SS STRUCTURE
.PP
\f[I]iq\f[R] consists of shell functions, each of which performs a basic
math operation.
The main functions are intuitively-named and mostly follow the same
basic syntax and usage.
.PP
Externally, \f[I]iq\f[R] has \f[I]Zero Dependencies\f[R], other than the
shell itself.
Internally, each public function acts like a separate program and takes
care of its\[cq] own input/output, to minimize dependencies between
functions.
.PP
\f[I]iq\f[R] is written completely in minimal shell language, so it runs
under all popular Linux/Unix shells, like \f[I]bash\f[R], \f[I]zsh\f[R],
\f[I]dash\f[R], \f[I]ksh\f[R] and \f[I]busybox-ash\f[R].
It neither reads nor writes to any file and calls no external programs.
.SS SYNTAX
.PP
The basic command syntax of the \f[I]iq\f[R] functions is:
.PP
\f[B]Function-Name\f[R] \f[B]Number1\f[R] \f[B]Operator\f[R]
\f[B]Number2\f[R]
.PP
where Function-Name is one of: \f[I]add\f[R] \f[I]mul\f[R] \f[I]div\f[R]
\f[I]tsst\f[R]
.PP
The functions \f[I]add\f[R], \f[I]mul\f[R] and \f[I]div\f[R] support
scaling of the output, with the `-s?' option, which truncates answers to
the desired precision.
When used, the scaling option should be the first parameter after
Function-name.
.PP
When calculating a series of inputs with \f[I]add\f[R] or \f[I]mul\f[R],
scaling is only performed after the last operation.
Otherwise they return the full answer without truncating.
.PP
If specified scale is zero `-s0', output is returned in integer form..
.PP
Final results from \f[I]mul\f[R] and \f[I]div\f[R] can be rounded using
any one of 5 methods:
.PP
\f[I]half-up\f[R], \f[I]half-even\f[R], \f[I]floor\f[R],
\f[I]ceiling\f[R] or \f[I]truncation\f[R]
.PP
Rounding is done only if requested.
.PP
See below for syntax and usage of \f[I]cmp3w\f[R] and \f[I]round\f[R].
.SS OPERATORS
.PP
\f[I]div\f[R] always requires one the operators `/' `%' `m' or `qr'
.PP
\f[I]mul\f[R] doesn\[cq]t require an operator, but allows either `x' or
`X -do not use the asterisk'*\[cq]
.PP
\f[I]add\f[R] doesn\[cq]t need operators, except when to avoid
double-negatives in scripting
.PP
\f[I]tsst\f[R] uses the same numeric comparison operators as the
shell\[cq]s `test' builtin:
.PP
`-lt' `-le' `-eq' `-ge' `-gt' or `-ne'
.SS SCALE
.PP
Scale values must be positive integers, and signify the number of places
after the Decimal Point.
.PP
There are no hard limits on scale/precision for any of the Basic
Arithmetic operations.
.SH EXPRESSIONS
.PP
\f[B]iq\f[R] takes advantage of the shell\[cq]s native white-space
separation of operators and values, so expressions use syntax similar to
the shell itself or the `expr' program.
.PP
All input elements must be space-separated: `add 2.347 + 3.7' not: `add
2.347+3.7'
.PP
\f[B]iq\f[R] does not process parenthetic expressions like (242+(3*4)).
But nesting can be done using the shells built-in capabilities, like
this:
.IP
.nf
\f[C]
iq add 242 $(iq mul 3 4 )
var=$(iq add 242 $(iq mul 3 4))
In scripts or in-session mode:
add 242 $( mul 3 4 )
var=$(add 242 $(mul 3 4))
\f[R]
.fi
.SH BASIC MATH FUNCTIONS
.PP
Items inside square brackets `[]' are optional
.PP
Required Items are shown in parentheses `()'
.PP
\f[B]add\f[R] \[em]- Addition and Subtraction of 2 or more numbers
.IP
.nf
\f[C]
Usage: \[aq]add [-s?] num1 [+-] num2 ... numN\[aq] 

If scale is omitted or \[aq]-soff\[aq], no truncation is done
Example: \[aq]add 2.340876 + 1827.749048\[aq] = 1830.089924
Example: \[aq]add 2.340876 - 1827.749048\[aq] = -1825.408172

Otherwise, result is truncated to the given scale
Example: \[aq]add -s4 2.340876 + 1827.749048\[aq] = 1830.0899

If scale is zero \[aq]-s0\[aq], output is in integer form
Example: \[aq]add -s0 2.340876 1827.749048\[aq] = 1830

When summing a series of inputs, results are only 
truncated after the last calculation. Operators are
optional. Currently, no rounding is done by \[aq]add\[aq].
\f[R]
.fi
.PP
\f[B]mul\f[R] \[em]- Multiplication of 2 or more numbers
.IP
.nf
\f[C]
Usage: \[aq]mul [-s?] [-r...] num1 [xX] num2 ... numN\[aq]

Operators are optional.
If the scale option is omitted or set to off \[aq]-soff\[aq],
no truncation or rounding of the result is done.
Example: \[aq]mul 2.340876445 x 1827.74904\[aq] = 4278.5346751073628

If scale is set to zero, result is truncated to integer.
Example: \[aq]mul -s0 2.340876445 x 1827.74904\[aq] = 4278

Otherwise, final result is truncated to the given scale.
Example: \[aq]mul -s4 2.340876445 X 1827.74904\[aq] = 4278.5346

Or, use the \[aq]-r..\[aq] options to round results, using
one method from: -rhfev , -rhfup , -rceil, -rflor, -rtrnc
for half-up, half-even, ceiling, floor or truncate.

Example(normal): \[aq]mul -s4 2.340876445 1827.74904\[aq] = 4278.5346
Example: \[aq]mul -s2 -rceil 2.340876445 1827.74904\[aq] = 4278.54

If the result is shorter than the given scale, then the
answer is exact and no rounding or truncation is done.
Results are only truncated or rounded after the final
calculation of a series of inputs.
\f[R]
.fi
.PP
\f[B]div\f[R] \[em]- Division, Remainder and Modulo
.IP
.nf
\f[C]
Usage: \[aq]div [-s?] [-r..] num1 ( / % m qr ) num2\[aq]

\[aq]div\[aq] requires an operator: / % m or \[aq]qr\[aq]
Example: \[aq]div -s8 3.52 / 1.4\[aq] = 2.51428571

If not given, the default scale value 5 is used:
Example: \[aq]div 3.52 / 1.4\[aq] = 2.51428
Example: \[aq]div -s0 3.52 / 1.4\[aq] = 2

Remainder and Modulo operations:
div -s8 -3.52 / 1.4 = -2.51428571 {normal division}

\[aq]%\[aq] returns the shell-and-C-style remainder
div -s2 -3.52 % 1.4 = -0.72

\[aq]m\[aq] returns the floored python-style modulo
div -s2 -3.52 m 1.4 = 0.68

\[aq]qr\[aq] (divmod) returns quotient and remainder
div -s2 -3.52 qr 1.4  =  -2.0 -0.72

The \[aq]-r...\[aq] option performs rounding after full division,
using one method from: -rhfup, -rhfev, -rceil, -rflor, -rtrnc
for half-up, half-even, ceiling, floor or truncate.
div -s20  -2.340876 / 17.749048         = -0.13188741165159956748
div -s17 -2.340876 / 17.749048          = -0.13188741165159956
div -s17 -rhfup  -2.340876 / 17.749048  = -0.13188741165159957

If the result is shorter than the given scale, then the
answer is exact and no rounding or truncation is done.
No rounding is done during modulo/remainder operations.
\f[R]
.fi
.PP
\f[B]tsst\f[R] \[em]- Numeric Comparison of integer or decimal numbers
.IP
.nf
\f[C]
Usage: \[aq]tsst num1 (operator) num2\[aq]
Operators: -lt -le -eq -ge -gt -ne

\[aq]tsst\[aq] is used like the shells\[aq] \[aq]test\[aq] or \[aq][\[aq] built-ins
returning a true/false condition of the comparison.
Examples as used from the command-line:
Example: \[aq]tsst 4.22 -lt 6.3 ; echo $?\[aq]
Example: \[aq]tsst 4.22 -lt 6.3 && echo less\[aq]

In scripts, \[aq]tsst\[aq] can be used in if/while/until structures:
if tsst 4.22 -lt 6.3 ; then ....
while tsst 4.22 -lt 6.3 ; do ....
\f[R]
.fi
.PP
\f[B]cmp3w\f[R] \[em]- 3-way Global Comparison of integer or decimal
numbers
.IP
.nf
\f[C]
Usage: \[aq]cmp3w num1 num2\[aq]

Relatively compares 2 decimal numbers, returns: \[aq]<\[aq] \[aq]=\[aq] or \[aq]>\[aq]
Example: \[aq]cmp3w -234.57 -234.55\[aq] returns: \[aq]<\[aq] (to stdout)

\[aq]cmp3w\[aq] is the back-end for \[aq]tsst\[aq] and is also used alone
by other functions, especially where 3 different actions
are wanted, for each of the 3 conditions.
\f[R]
.fi
.PP
\f[B]round\f[R] \[em]- Rounding of integer or decimal Numbers
.IP
.nf
\f[C]
Usage: round (method) [-s?] decimal-number

Where \[aq]method\[aq] is \[aq]ceil\[aq] \[aq]flor\[aq] \[aq]hfup\[aq] \[aq]hfev\[aq] or \[aq]trnc\[aq]. 
That is, ceiling, floor, half-up, half-even or truncation.
Note that \[aq]method\[aq] comes before the \[aq]-s?\[aq] scale option.

Example: \[aq]round ceil -s0 4.001\[aq] returns \[aq]5\[aq]
Example: \[aq]round flor -s2 -4.001\[aq] returns \[aq]-4.01\[aq]
Example: \[aq]round hfup -s2 4.005\[aq] returns \[aq]4.01\[aq]
Example: \[aq]round hfev -s9 0.9999999985\[aq] returns \[aq]0.999999998\[aq]
Example: \[aq]round hfev -s9 0.9999999995\[aq] returns \[aq]1.000000000\[aq]

Input must be at least 1 digit longer than requested scale.
Otherwise, no rounding is done.

Half-up is the \[aq]normal\[aq] most-used method of rounding. 
Half-even rounding is used in financial calculations.
Truncation is effectively toward-zero rounding.
\f[R]
.fi
.SH INTERACTIVE MODE
.PP
When run using the \f[I]-i\f[R] option, \f[I]iq\f[R] will start in
Interactive Mode, allowing you to make a series of calculations, before
exiting the program.
.PP
You can also load any of the extra Modules for more functionality.
.PP
The available Modules are \f[I]iq+\f[R], \f[I]iq_trig\f[R],
\f[I]iq_misc\f[R], \f[I]iq_util\f[R] and \f[I]iq_ai\f[R].
.SH ONE-SHOT MODE
.PP
\f[I]iq\f[R] is easy to use from the CLI as a one-shot calcuclator and
needs no echo or piping of inputs as with `bc', `dc' or `awk'.
.IP
.nf
\f[C]
Instead of: echo \[dq]scale=5; 2.7182*3.1416\[dq] |bc
iq mul -s5 2.7182 3.1416 
\f[R]
.fi
.PP
Assigning results to a variable is also easier:
.IP
.nf
\f[C]
Instead of: a=$(echo \[dq]scale=5; 2.7182*3.1416\[dq] |bc)
a=$(iq mul -s5 2.7182 3.1416)
\f[R]
.fi
.SH ON-LINE MODE
.PP
To `source' iq into your shell session with the `.' (dot) builtin:
.IP
.nf
\f[C]
src=1 . iq
\f[R]
.fi
.PP
This makes the \f[I]iq\f[R] functions available anytime during your
shell session, but they stay in the background when not used.
.SH SCRIPTING
.PP
\f[B]IQ\f[R] was especially designed for heavy use in scripts, so this
way of using it provides the most benefits.
.IP
.nf
\f[C]
Normally, when a script uses a calculator like \[aq]bc\[aq] or \[aq]awk\[aq], 
that program has to be run in a separate process. When many
calculations are needed, the start-up latency for those adds up.

By sourcing *iq* into your script instead, the latency for loading
*iq* occurs only once. After that, the functions are available for
execution in your script. But, since they are shell functions, they
are run in-line in the main process and do not cause the spawning
of new processes.
\f[R]
.fi
.PP
To include \f[I]iq\f[R] in your shell script, simply `source' it into
your script.
.IP
.nf
\f[C]
Just put a line like this near the beginning:
src=1 . iq
or:
src=1 . /path/to/iq
\f[R]
.fi
.PP
Then, any further needed functions or modules can be sourced or copied
into your script.
.PP
The comments above each function list the dependencies of that function.
.PP
A slightly altered version of the Main Functions is contained in the
file \f[I]math.h.sh\f[R], for easier, more-compact inclusion in scripts.
See the bottom of \f[I]math.h.sh\f[R] for complete instructions for
using it.
.SH AUTHOR
.PP
Gilbert Ashley <https://github.com/ShellCanToo/iQalc>
.SH SEE ALSO
.PP
\f[B]iq+(1)\f[R] \f[B]iq_trig(1)\f[R] \f[B]iq_misc(1)\f[R]
\f[B]iq_util(1)\f[R]
